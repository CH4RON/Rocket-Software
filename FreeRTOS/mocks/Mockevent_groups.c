/* AUTOGENERATED FILE. DO NOT EDIT. */


#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#include "FreeRTOS.h"
#include "Mockevent_groups.h"
#include "cmock.h"

static const char* CMockString_pvEventGroup = "pvEventGroup";
static const char* CMockString_pxEventGroupBuffer = "pxEventGroupBuffer";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_ulBitsToClear = "ulBitsToClear";
static const char* CMockString_ulBitsToSet = "ulBitsToSet";
static const char* CMockString_uxBitsToClear = "uxBitsToClear";
static const char* CMockString_uxBitsToSet = "uxBitsToSet";
static const char* CMockString_uxBitsToWaitFor = "uxBitsToWaitFor";
static const char* CMockString_uxEventGroupGetNumber = "uxEventGroupGetNumber";
static const char* CMockString_uxEventGroupNumber = "uxEventGroupNumber";
static const char* CMockString_vEventGroupClearBitsCallback = "vEventGroupClearBitsCallback";
static const char* CMockString_vEventGroupDelete = "vEventGroupDelete";
static const char* CMockString_vEventGroupSetBitsCallback = "vEventGroupSetBitsCallback";
static const char* CMockString_vEventGroupSetNumber = "vEventGroupSetNumber";
static const char* CMockString_xClearOnExit = "xClearOnExit";
static const char* CMockString_xEventGroup = "xEventGroup";
static const char* CMockString_xEventGroupClearBits = "xEventGroupClearBits";
static const char* CMockString_xEventGroupClearBitsFromISR = "xEventGroupClearBitsFromISR";
static const char* CMockString_xEventGroupCreate = "xEventGroupCreate";
static const char* CMockString_xEventGroupCreateStatic = "xEventGroupCreateStatic";
static const char* CMockString_xEventGroupGetBitsFromISR = "xEventGroupGetBitsFromISR";
static const char* CMockString_xEventGroupSetBits = "xEventGroupSetBits";
static const char* CMockString_xEventGroupSetBitsFromISR = "xEventGroupSetBitsFromISR";
static const char* CMockString_xEventGroupSync = "xEventGroupSync";
static const char* CMockString_xEventGroupWaitBits = "xEventGroupWaitBits";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xWaitForAllBits = "xWaitForAllBits";

typedef struct _CMOCK_xEventGroupCreate_CALL_INSTANCE {
    UNITY_LINE_TYPE LineNumber;
    EventGroupHandle_t ReturnVal;

} CMOCK_xEventGroupCreate_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventGroupHandle_t ReturnVal;
  StaticEventGroup_t* Expected_pxEventGroupBuffer;

} CMOCK_xEventGroupCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupWaitBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventBits_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToWaitFor;
  BaseType_t Expected_xClearOnExit;
  BaseType_t Expected_xWaitForAllBits;
  TickType_t Expected_xTicksToWait;

} CMOCK_xEventGroupWaitBits_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupClearBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventBits_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToClear;

} CMOCK_xEventGroupClearBits_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToClear;

} CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupSetBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventBits_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToSet;

} CMOCK_xEventGroupSetBits_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToSet;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupSync_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventBits_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToSet;
  EventBits_t Expected_uxBitsToWaitFor;
  TickType_t Expected_xTicksToWait;

} CMOCK_xEventGroupSync_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventBits_t ReturnVal;
  EventGroupHandle_t Expected_xEventGroup;

} CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  EventGroupHandle_t Expected_xEventGroup;

} CMOCK_vEventGroupDelete_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  void* Expected_pvEventGroup;
  uint32_t Expected_ulBitsToSet;

} CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  void* Expected_pvEventGroup;
  uint32_t Expected_ulBitsToClear;

} CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE;

typedef struct _CMOCK_uxEventGroupGetNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  void* Expected_xEventGroup;

} CMOCK_uxEventGroupGetNumber_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupSetNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  void* Expected_xEventGroup;
  UBaseType_t Expected_uxEventGroupNumber;

} CMOCK_vEventGroupSetNumber_CALL_INSTANCE;

static struct Mockevent_groupsInstance
{
  CMOCK_MEM_INDEX_TYPE xEventGroupCreate_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupCreateStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupWaitBits_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupClearBits_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupClearBitsFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupSetBits_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupSetBitsFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupSync_CallInstance;
  CMOCK_MEM_INDEX_TYPE xEventGroupGetBitsFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vEventGroupDelete_CallInstance;
  CMOCK_MEM_INDEX_TYPE vEventGroupSetBitsCallback_CallInstance;
  CMOCK_MEM_INDEX_TYPE vEventGroupClearBitsCallback_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxEventGroupGetNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE vEventGroupSetNumber_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockevent_groups_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xEventGroupCreate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupCreateStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupWaitBits_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupWaitBits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupClearBits_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupClearBits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupClearBitsFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupClearBitsFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupSetBits_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupSetBits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupSetBitsFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupSetBitsFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupSync_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupSync);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xEventGroupGetBitsFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupGetBitsFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vEventGroupDelete_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vEventGroupSetBitsCallback_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupSetBitsCallback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vEventGroupClearBitsCallback_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupClearBitsCallback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxEventGroupGetNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxEventGroupGetNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vEventGroupSetNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupSetNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockevent_groups_Init(void)
{
  Mockevent_groups_Destroy();
}

void Mockevent_groups_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

EventGroupHandle_t xEventGroupCreate(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupCreate);
  cmock_call_instance = (CMOCK_xEventGroupCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupCreate_CallInstance);
  Mock.xEventGroupCreate_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupCreate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xEventGroupCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreate_CALL_INSTANCE));
  CMOCK_xEventGroupCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreate_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventGroupHandle_t[sizeof(cmock_to_return) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
}

EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t* pxEventGroupBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupCreateStatic);
  cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupCreateStatic_CallInstance);
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupCreateStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupCreateStatic,CMockString_pxEventGroupBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxEventGroupBuffer), (void*)(pxEventGroupBuffer), sizeof(StaticEventGroup_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupCreateStatic(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance, StaticEventGroup_t* pxEventGroupBuffer)
{
  cmock_call_instance->Expected_pxEventGroupBuffer = pxEventGroupBuffer;
}

void xEventGroupCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StaticEventGroup_t* pxEventGroupBuffer, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE));
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupCreateStatic(cmock_call_instance, pxEventGroupBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventGroupHandle_t[sizeof(cmock_to_return) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
}

EventBits_t xEventGroupWaitBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupWaitBits);
  cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupWaitBits_CallInstance);
  Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupWaitBits_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_uxBitsToWaitFor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xClearOnExit);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xClearOnExit), (void*)(&xClearOnExit), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xWaitForAllBits);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xWaitForAllBits), (void*)(&xWaitForAllBits), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupWaitBits(CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor),
         sizeof(EventBits_t[sizeof(uxBitsToWaitFor) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xClearOnExit), (void*)(&xClearOnExit),
         sizeof(BaseType_t[sizeof(xClearOnExit) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xWaitForAllBits), (void*)(&xWaitForAllBits),
         sizeof(BaseType_t[sizeof(xWaitForAllBits) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xEventGroupWaitBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupWaitBits_CALL_INSTANCE));
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupWaitBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupWaitBits(cmock_call_instance, xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupClearBits);
  cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupClearBits_CallInstance);
  Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupClearBits_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBits,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBits,CMockString_uxBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupClearBits(CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear),
         sizeof(EventBits_t[sizeof(uxBitsToClear) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupClearBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBits_CALL_INSTANCE));
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupClearBits(cmock_call_instance, xEventGroup, uxBitsToClear);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

BaseType_t xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupClearBitsFromISR);
  cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupClearBitsFromISR_CallInstance);
  Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupClearBitsFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBitsFromISR,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBitsFromISR,CMockString_uxBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupClearBitsFromISR(CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear),
         sizeof(EventBits_t[sizeof(uxBitsToClear) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupClearBitsFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBitsFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupClearBitsFromISR(cmock_call_instance, xEventGroup, uxBitsToClear);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupSetBits);
  cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupSetBits_CallInstance);
  Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSetBits_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBits,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBits,CMockString_uxBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupSetBits(CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet),
         sizeof(EventBits_t[sizeof(uxBitsToSet) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupSetBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBits_CALL_INSTANCE));
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupSetBits(cmock_call_instance, xEventGroup, uxBitsToSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupSetBitsFromISR);
  cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupSetBitsFromISR_CallInstance);
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSetBitsFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBitsFromISR,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBitsFromISR,CMockString_uxBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBitsFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupSetBitsFromISR(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet),
         sizeof(EventBits_t[sizeof(uxBitsToSet) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xEventGroupSetBitsFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBitsFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupSetBitsFromISR(cmock_call_instance, xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupSync);
  cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupSync_CallInstance);
  Mock.xEventGroupSync_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSync_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_uxBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_uxBitsToWaitFor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupSync(CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet),
         sizeof(EventBits_t[sizeof(uxBitsToSet) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor),
         sizeof(EventBits_t[sizeof(uxBitsToWaitFor) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xEventGroupSync_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSync_CALL_INSTANCE));
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSync_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSync_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupSync(cmock_call_instance, xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

EventBits_t xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupGetBitsFromISR);
  cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupGetBitsFromISR_CallInstance);
  Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupGetBitsFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupGetBitsFromISR,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupGetBitsFromISR(CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
}

void xEventGroupGetBitsFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupGetBitsFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xEventGroupGetBitsFromISR(cmock_call_instance, xEventGroup);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void vEventGroupDelete(EventGroupHandle_t xEventGroup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupDelete);
  cmock_call_instance = (CMOCK_vEventGroupDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupDelete_CallInstance);
  Mock.vEventGroupDelete_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupDelete_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupDelete,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupDelete(CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
}

void vEventGroupDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupDelete_CALL_INSTANCE));
  CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupDelete_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupDelete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vEventGroupDelete(cmock_call_instance, xEventGroup);
}

void vEventGroupSetBitsCallback(void* pvEventGroup, const uint32_t ulBitsToSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupSetBitsCallback);
  cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupSetBitsCallback_CallInstance);
  Mock.vEventGroupSetBitsCallback_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupSetBitsCallback_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetBitsCallback,CMockString_pvEventGroup);
    if (cmock_call_instance->Expected_pvEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(pvEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvEventGroup, pvEventGroup, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetBitsCallback,CMockString_ulBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToSet, ulBitsToSet, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupSetBitsCallback(CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance, void* pvEventGroup, const uint32_t ulBitsToSet)
{
  cmock_call_instance->Expected_pvEventGroup = pvEventGroup;
  cmock_call_instance->Expected_ulBitsToSet = ulBitsToSet;
}

void vEventGroupSetBitsCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, const uint32_t ulBitsToSet)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetBitsCallback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vEventGroupSetBitsCallback(cmock_call_instance, pvEventGroup, ulBitsToSet);
}

void vEventGroupClearBitsCallback(void* pvEventGroup, const uint32_t ulBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupClearBitsCallback);
  cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupClearBitsCallback_CallInstance);
  Mock.vEventGroupClearBitsCallback_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupClearBitsCallback_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupClearBitsCallback,CMockString_pvEventGroup);
    if (cmock_call_instance->Expected_pvEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(pvEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvEventGroup, pvEventGroup, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupClearBitsCallback,CMockString_ulBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClear, ulBitsToClear, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupClearBitsCallback(CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance, void* pvEventGroup, const uint32_t ulBitsToClear)
{
  cmock_call_instance->Expected_pvEventGroup = pvEventGroup;
  cmock_call_instance->Expected_ulBitsToClear = ulBitsToClear;
}

void vEventGroupClearBitsCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, const uint32_t ulBitsToClear)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupClearBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupClearBitsCallback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vEventGroupClearBitsCallback(cmock_call_instance, pvEventGroup, ulBitsToClear);
}

UBaseType_t uxEventGroupGetNumber(void* xEventGroup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxEventGroupGetNumber);
  cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxEventGroupGetNumber_CallInstance);
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemNext(Mock.uxEventGroupGetNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxEventGroupGetNumber,CMockString_xEventGroup);
    if (cmock_call_instance->Expected_xEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(xEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_xEventGroup, xEventGroup, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxEventGroupGetNumber(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance, void* xEventGroup)
{
  cmock_call_instance->Expected_xEventGroup = xEventGroup;
}

void uxEventGroupGetNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, void* xEventGroup, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE));
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemChain(Mock.uxEventGroupGetNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxEventGroupGetNumber(cmock_call_instance, xEventGroup);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vEventGroupSetNumber(void* xEventGroup, UBaseType_t uxEventGroupNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupSetNumber);
  cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupSetNumber_CallInstance);
  Mock.vEventGroupSetNumber_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupSetNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetNumber,CMockString_xEventGroup);
    if (cmock_call_instance->Expected_xEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(xEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_xEventGroup, xEventGroup, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetNumber,CMockString_uxEventGroupNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxEventGroupNumber), (void*)(&uxEventGroupNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupSetNumber(CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance, void* xEventGroup, UBaseType_t uxEventGroupNumber)
{
  cmock_call_instance->Expected_xEventGroup = xEventGroup;
  memcpy((void*)(&cmock_call_instance->Expected_uxEventGroupNumber), (void*)(&uxEventGroupNumber),
         sizeof(UBaseType_t[sizeof(uxEventGroupNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vEventGroupSetNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, void* xEventGroup, UBaseType_t uxEventGroupNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetNumber_CALL_INSTANCE));
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetNumber_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vEventGroupSetNumber(cmock_call_instance, xEventGroup, uxEventGroupNumber);
}

