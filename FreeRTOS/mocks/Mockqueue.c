/* AUTOGENERATED FILE. DO NOT EDIT. */
#include "Mockqueue.h"

#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#include "cmock.h"

static const char* CMockString_pcQueueGetName = "pcQueueGetName";
#include "FreeRTOS.h"
static const char* CMockString_pcQueueName = "pcQueueName";
static const char* CMockString_pucQueueStorage = "pucQueueStorage";
static const char* CMockString_pvBuffer = "pvBuffer";
static const char* CMockString_pvItemToQueue = "pvItemToQueue";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxStaticQueue = "pxStaticQueue";
static const char* CMockString_pxTaskWoken = "pxTaskWoken";
static const char* CMockString_ucQueueGetQueueType = "ucQueueGetQueueType";
static const char* CMockString_ucQueueType = "ucQueueType";
static const char* CMockString_uxEventQueueLength = "uxEventQueueLength";
static const char* CMockString_uxInitialCount = "uxInitialCount";
static const char* CMockString_uxItemSize = "uxItemSize";
static const char* CMockString_uxMaxCount = "uxMaxCount";
static const char* CMockString_uxQueueGetQueueNumber = "uxQueueGetQueueNumber";
static const char* CMockString_uxQueueLength = "uxQueueLength";
static const char* CMockString_uxQueueMessagesWaiting = "uxQueueMessagesWaiting";
static const char* CMockString_uxQueueMessagesWaitingFromISR = "uxQueueMessagesWaitingFromISR";
static const char* CMockString_uxQueueNumber = "uxQueueNumber";
static const char* CMockString_uxQueueSpacesAvailable = "uxQueueSpacesAvailable";
static const char* CMockString_vQueueAddToRegistry = "vQueueAddToRegistry";
static const char* CMockString_vQueueDelete = "vQueueDelete";
static const char* CMockString_vQueueSetQueueNumber = "vQueueSetQueueNumber";
static const char* CMockString_vQueueUnregisterQueue = "vQueueUnregisterQueue";
static const char* CMockString_vQueueWaitForMessageRestricted = "vQueueWaitForMessageRestricted";
static const char* CMockString_xCoRoutinePreviouslyWoken = "xCoRoutinePreviouslyWoken";
static const char* CMockString_xCopyPosition = "xCopyPosition";
static const char* CMockString_xMutex = "xMutex";
static const char* CMockString_xNewQueue = "xNewQueue";
static const char* CMockString_xQueue = "xQueue";
static const char* CMockString_xQueueAddToSet = "xQueueAddToSet";
static const char* CMockString_xQueueCRReceive = "xQueueCRReceive";
static const char* CMockString_xQueueCRReceiveFromISR = "xQueueCRReceiveFromISR";
static const char* CMockString_xQueueCRSend = "xQueueCRSend";
static const char* CMockString_xQueueCRSendFromISR = "xQueueCRSendFromISR";
static const char* CMockString_xQueueCreateCountingSemaphore = "xQueueCreateCountingSemaphore";
static const char* CMockString_xQueueCreateCountingSemaphoreStatic = "xQueueCreateCountingSemaphoreStatic";
static const char* CMockString_xQueueCreateMutex = "xQueueCreateMutex";
static const char* CMockString_xQueueCreateMutexStatic = "xQueueCreateMutexStatic";
static const char* CMockString_xQueueCreateSet = "xQueueCreateSet";
static const char* CMockString_xQueueGenericCreate = "xQueueGenericCreate";
static const char* CMockString_xQueueGenericCreateStatic = "xQueueGenericCreateStatic";
static const char* CMockString_xQueueGenericReset = "xQueueGenericReset";
static const char* CMockString_xQueueGenericSend = "xQueueGenericSend";
static const char* CMockString_xQueueGenericSendFromISR = "xQueueGenericSendFromISR";
static const char* CMockString_xQueueGetMutexHolder = "xQueueGetMutexHolder";
static const char* CMockString_xQueueGetMutexHolderFromISR = "xQueueGetMutexHolderFromISR";
static const char* CMockString_xQueueGiveFromISR = "xQueueGiveFromISR";
static const char* CMockString_xQueueGiveMutexRecursive = "xQueueGiveMutexRecursive";
static const char* CMockString_xQueueIsQueueEmptyFromISR = "xQueueIsQueueEmptyFromISR";
static const char* CMockString_xQueueIsQueueFullFromISR = "xQueueIsQueueFullFromISR";
static const char* CMockString_xQueueOrSemaphore = "xQueueOrSemaphore";
static const char* CMockString_xQueuePeek = "xQueuePeek";
static const char* CMockString_xQueuePeekFromISR = "xQueuePeekFromISR";
static const char* CMockString_xQueueReceive = "xQueueReceive";
static const char* CMockString_xQueueReceiveFromISR = "xQueueReceiveFromISR";
static const char* CMockString_xQueueRemoveFromSet = "xQueueRemoveFromSet";
static const char* CMockString_xQueueSelectFromSet = "xQueueSelectFromSet";
static const char* CMockString_xQueueSelectFromSetFromISR = "xQueueSelectFromSetFromISR";
static const char* CMockString_xQueueSemaphoreTake = "xQueueSemaphoreTake";
static const char* CMockString_xQueueSet = "xQueueSet";
static const char* CMockString_xQueueTakeMutexRecursive = "xQueueTakeMutexRecursive";
static const char* CMockString_xSemaphore = "xSemaphore";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xWaitIndefinitely = "xWaitIndefinitely";

typedef struct _CMOCK_xQueueGenericSend_CALL_INSTANCE {
    UNITY_LINE_TYPE LineNumber;
    BaseType_t ReturnVal;
    QueueHandle_t Expected_xQueue;
    const void* Expected_pvItemToQueue;
    TickType_t Expected_xTicksToWait;
    BaseType_t Expected_xCopyPosition;

} CMOCK_xQueueGenericSend_CALL_INSTANCE;

typedef struct _CMOCK_xQueuePeek_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueuePeek_CALL_INSTANCE;

typedef struct _CMOCK_xQueuePeekFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;

} CMOCK_xQueuePeekFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueReceive_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE;

typedef struct _CMOCK_vQueueDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t Expected_xQueue;

} CMOCK_vQueueDelete_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  BaseType_t Expected_xCopyPosition;

} CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xQueueGiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xQueueReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  BaseType_t Expected_xCoRoutinePreviouslyWoken;

} CMOCK_xQueueCRSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  BaseType_t* Expected_pxTaskWoken;

} CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRSend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueCRSend_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueCRReceive_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateMutex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  uint8_t Expected_ucQueueType;

} CMOCK_xQueueCreateMutex_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  uint8_t Expected_ucQueueType;
  StaticQueue_t* Expected_pxStaticQueue;

} CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  UBaseType_t Expected_uxMaxCount;
  UBaseType_t Expected_uxInitialCount;

} CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  UBaseType_t Expected_uxMaxCount;
  UBaseType_t Expected_uxInitialCount;
  StaticQueue_t* Expected_pxStaticQueue;

} CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSemaphoreTake_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueSemaphoreTake_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGetMutexHolder_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;
  QueueHandle_t Expected_xSemaphore;

} CMOCK_xQueueGetMutexHolder_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;
  QueueHandle_t Expected_xSemaphore;

} CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xMutex;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xMutex;

} CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE;

typedef struct _CMOCK_vQueueAddToRegistry_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t Expected_xQueue;
  const char* Expected_pcQueueName;

} CMOCK_vQueueAddToRegistry_CALL_INSTANCE;

typedef struct _CMOCK_vQueueUnregisterQueue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t Expected_xQueue;

} CMOCK_vQueueUnregisterQueue_CALL_INSTANCE;

typedef struct _CMOCK_pcQueueGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_pcQueueGetName_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  UBaseType_t Expected_uxQueueLength;
  UBaseType_t Expected_uxItemSize;
  uint8_t Expected_ucQueueType;

} CMOCK_xQueueGenericCreate_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  UBaseType_t Expected_uxQueueLength;
  UBaseType_t Expected_uxItemSize;
  uint8_t* Expected_pucQueueStorage;
  StaticQueue_t* Expected_pxStaticQueue;
  uint8_t Expected_ucQueueType;

} CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueSetHandle_t ReturnVal;
  UBaseType_t Expected_uxEventQueueLength;

} CMOCK_xQueueCreateSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueAddToSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueSetMemberHandle_t Expected_xQueueOrSemaphore;
  QueueSetHandle_t Expected_xQueueSet;

} CMOCK_xQueueAddToSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueRemoveFromSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueSetMemberHandle_t Expected_xQueueOrSemaphore;
  QueueSetHandle_t Expected_xQueueSet;

} CMOCK_xQueueRemoveFromSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSelectFromSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueSetMemberHandle_t ReturnVal;
  QueueSetHandle_t Expected_xQueueSet;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueSelectFromSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueSetMemberHandle_t ReturnVal;
  QueueSetHandle_t Expected_xQueueSet;

} CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t Expected_xQueue;
  TickType_t Expected_xTicksToWait;
  BaseType_t Expected_xWaitIndefinitely;

} CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericReset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;
  BaseType_t Expected_xNewQueue;

} CMOCK_xQueueGenericReset_CALL_INSTANCE;

typedef struct _CMOCK_vQueueSetQueueNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t Expected_xQueue;
  UBaseType_t Expected_uxQueueNumber;

} CMOCK_vQueueSetQueueNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE;

typedef struct _CMOCK_ucQueueGetQueueType_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;
  QueueHandle_t Expected_xQueue;

} CMOCK_ucQueueGetQueueType_CALL_INSTANCE;

static struct MockqueueInstance
{
  CMOCK_MEM_INDEX_TYPE xQueueGenericSend_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueuePeek_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueuePeekFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueReceive_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxQueueMessagesWaiting_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxQueueSpacesAvailable_CallInstance;
  CMOCK_MEM_INDEX_TYPE vQueueDelete_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGenericSendFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGiveFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueReceiveFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueIsQueueEmptyFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueIsQueueFullFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxQueueMessagesWaitingFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCRSendFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCRReceiveFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCRSend_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCRReceive_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCreateMutex_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCreateMutexStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCreateCountingSemaphore_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCreateCountingSemaphoreStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueSemaphoreTake_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGetMutexHolder_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGetMutexHolderFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueTakeMutexRecursive_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGiveMutexRecursive_CallInstance;
  CMOCK_MEM_INDEX_TYPE vQueueAddToRegistry_CallInstance;
  CMOCK_MEM_INDEX_TYPE vQueueUnregisterQueue_CallInstance;
  CMOCK_MEM_INDEX_TYPE pcQueueGetName_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGenericCreate_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGenericCreateStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueCreateSet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueAddToSet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueRemoveFromSet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueSelectFromSet_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueSelectFromSetFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vQueueWaitForMessageRestricted_CallInstance;
  CMOCK_MEM_INDEX_TYPE xQueueGenericReset_CallInstance;
  CMOCK_MEM_INDEX_TYPE vQueueSetQueueNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxQueueGetQueueNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE ucQueueGetQueueType_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockqueue_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xQueueGenericSend_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericSend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueuePeek_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueuePeek);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueuePeekFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueuePeekFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueReceive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueReceive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxQueueMessagesWaiting_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaiting);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxQueueSpacesAvailable_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueSpacesAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vQueueDelete_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGenericSendFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericSendFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGiveFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueReceiveFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueReceiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueIsQueueEmptyFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueIsQueueEmptyFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueIsQueueFullFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueIsQueueFullFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxQueueMessagesWaitingFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaitingFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCRSendFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRSendFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCRReceiveFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRReceiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCRSend_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRSend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCRReceive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRReceive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCreateMutex_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateMutex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCreateMutexStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateMutexStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCreateCountingSemaphore_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphore);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCreateCountingSemaphoreStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphoreStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueSemaphoreTake_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueSemaphoreTake);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGetMutexHolder_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolder);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGetMutexHolderFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolderFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueTakeMutexRecursive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueTakeMutexRecursive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGiveMutexRecursive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGiveMutexRecursive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vQueueAddToRegistry_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueAddToRegistry);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vQueueUnregisterQueue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueUnregisterQueue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pcQueueGetName_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcQueueGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGenericCreate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGenericCreateStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueCreateSet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueAddToSet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueAddToSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueRemoveFromSet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueRemoveFromSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueSelectFromSet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueSelectFromSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueSelectFromSetFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueSelectFromSetFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vQueueWaitForMessageRestricted_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueWaitForMessageRestricted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xQueueGenericReset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericReset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vQueueSetQueueNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueSetQueueNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxQueueGetQueueNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueGetQueueNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ucQueueGetQueueType_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ucQueueGetQueueType);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockqueue_Init(void)
{
  Mockqueue_Destroy();
}

void Mockqueue_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericSend);
  cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericSend_CallInstance);
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericSend_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_xCopyPosition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericSend(CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition),
         sizeof(BaseType_t[sizeof(xCopyPosition) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGenericSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSend_CALL_INSTANCE));
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSend_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGenericSend(cmock_call_instance, xQueue, pvItemToQueue, xTicksToWait, xCopyPosition);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueuePeek(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueuePeek);
  cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueuePeek_CallInstance);
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeek_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeek,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeek,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeek,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueuePeek(CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueuePeek_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueuePeek(cmock_call_instance, xQueue, pvBuffer, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void* const pvBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueuePeekFromISR);
  cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueuePeekFromISR_CallInstance);
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeekFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeekFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeekFromISR,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueuePeekFromISR(CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
}

void xQueuePeekFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueuePeekFromISR(cmock_call_instance, xQueue, pvBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueReceive(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueReceive);
  cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueReceive_CallInstance);
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceive,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceive,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueReceive(CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueueReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueReceive(cmock_call_instance, xQueue, pvBuffer, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxQueueMessagesWaiting(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaiting);
  cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueMessagesWaiting_CallInstance);
  Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemNext(Mock.uxQueueMessagesWaiting_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxQueueMessagesWaiting,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueMessagesWaiting(CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void uxQueueMessagesWaiting_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaiting_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxQueueMessagesWaiting(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxQueueSpacesAvailable(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueSpacesAvailable);
  cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueSpacesAvailable_CallInstance);
  Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemNext(Mock.uxQueueSpacesAvailable_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxQueueSpacesAvailable,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueSpacesAvailable(CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void uxQueueSpacesAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE));
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.uxQueueSpacesAvailable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxQueueSpacesAvailable(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vQueueDelete(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueDelete);
  cmock_call_instance = (CMOCK_vQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueDelete_CallInstance);
  Mock.vQueueDelete_CallInstance = CMock_Guts_MemNext(Mock.vQueueDelete_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vQueueDelete,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueDelete(CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void vQueueDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueDelete_CALL_INSTANCE));
  CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueDelete_CallInstance = CMock_Guts_MemChain(Mock.vQueueDelete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vQueueDelete(cmock_call_instance, xQueue);
}

BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericSendFromISR);
  cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericSendFromISR_CallInstance);
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericSendFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_xCopyPosition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericSendFromISR(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  memcpy((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition),
         sizeof(BaseType_t[sizeof(xCopyPosition) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGenericSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSendFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGenericSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGiveFromISR);
  cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGiveFromISR_CallInstance);
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGiveFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGiveFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGiveFromISR(CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xQueueGiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGiveFromISR(cmock_call_instance, xQueue, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueReceiveFromISR);
  cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueReceiveFromISR_CallInstance);
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceiveFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceiveFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceiveFromISR,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueReceiveFromISR(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xQueueReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueIsQueueEmptyFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueIsQueueEmptyFromISR);
  cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueIsQueueEmptyFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueIsQueueEmptyFromISR(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueIsQueueEmptyFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueIsQueueEmptyFromISR(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueIsQueueFullFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueIsQueueFullFromISR);
  cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueIsQueueFullFromISR_CallInstance);
  Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueFullFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueIsQueueFullFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueIsQueueFullFromISR(CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueIsQueueFullFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueFullFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueIsQueueFullFromISR(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaitingFromISR);
  cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueMessagesWaitingFromISR_CallInstance);
  Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemNext(Mock.uxQueueMessagesWaitingFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxQueueMessagesWaitingFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueMessagesWaitingFromISR(CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void uxQueueMessagesWaitingFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaitingFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxQueueMessagesWaitingFromISR(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueCRSendFromISR(QueueHandle_t xQueue, const void* pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRSendFromISR);
  cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRSendFromISR_CallInstance);
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRSendFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSendFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSendFromISR,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSendFromISR,CMockString_xCoRoutinePreviouslyWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCoRoutinePreviouslyWoken), (void*)(&xCoRoutinePreviouslyWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRSendFromISR(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  memcpy((void*)(&cmock_call_instance->Expected_xCoRoutinePreviouslyWoken), (void*)(&xCoRoutinePreviouslyWoken),
         sizeof(BaseType_t[sizeof(xCoRoutinePreviouslyWoken) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueCRSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSendFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCRSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, xCoRoutinePreviouslyWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueCRReceiveFromISR(QueueHandle_t xQueue, void* pvBuffer, BaseType_t* pxTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRReceiveFromISR);
  cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRReceiveFromISR_CallInstance);
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRReceiveFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceiveFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceiveFromISR,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceiveFromISR,CMockString_pxTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTaskWoken), (void*)(pxTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRReceiveFromISR(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* pvBuffer, BaseType_t* pxTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pxTaskWoken = pxTaskWoken;
}

void xQueueCRReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* pvBuffer, BaseType_t* pxTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCRReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, pxTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueCRSend(QueueHandle_t xQueue, const void* pvItemToQueue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRSend);
  cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRSend_CallInstance);
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRSend_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSend,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSend,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSend,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRSend(CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* pvItemToQueue, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueueCRSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* pvItemToQueue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSend_CALL_INSTANCE));
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSend_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCRSend(cmock_call_instance, xQueue, pvItemToQueue, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueCRReceive(QueueHandle_t xQueue, void* pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRReceive);
  cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRReceive_CallInstance);
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRReceive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceive,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceive,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRReceive(CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* pvBuffer, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueueCRReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceive_CALL_INSTANCE));
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCRReceive(cmock_call_instance, xQueue, pvBuffer, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

QueueHandle_t xQueueCreateMutex(const uint8_t ucQueueType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateMutex);
  cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateMutex_CallInstance);
  Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateMutex_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateMutex,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateMutex(CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance, const uint8_t ucQueueType)
{
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
}

void xQueueCreateMutex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutex_CALL_INSTANCE));
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutex_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCreateMutex(cmock_call_instance, ucQueueType);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

QueueHandle_t xQueueCreateMutexStatic(const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateMutexStatic);
  cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateMutexStatic_CallInstance);
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateMutexStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateMutexStatic,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateMutexStatic,CMockString_pxStaticQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxStaticQueue), (void*)(pxStaticQueue), sizeof(StaticQueue_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateMutexStatic(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance, const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue)
{
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
  cmock_call_instance->Expected_pxStaticQueue = pxStaticQueue;
}

void xQueueCreateMutexStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutexStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCreateMutexStatic(cmock_call_instance, ucQueueType, pxStaticQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

QueueHandle_t xQueueCreateCountingSemaphore(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphore);
  cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateCountingSemaphore_CallInstance);
  Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateCountingSemaphore_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphore,CMockString_uxMaxCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphore,CMockString_uxInitialCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateCountingSemaphore(CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount),
         sizeof(UBaseType_t[sizeof(uxMaxCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount),
         sizeof(UBaseType_t[sizeof(uxInitialCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void xQueueCreateCountingSemaphore_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphore_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCreateCountingSemaphore(cmock_call_instance, uxMaxCount, uxInitialCount);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

QueueHandle_t xQueueCreateCountingSemaphoreStatic(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphoreStatic);
  cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance);
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphoreStatic,CMockString_uxMaxCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphoreStatic,CMockString_uxInitialCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphoreStatic,CMockString_pxStaticQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxStaticQueue), (void*)(pxStaticQueue), sizeof(StaticQueue_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateCountingSemaphoreStatic(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount),
         sizeof(UBaseType_t[sizeof(uxMaxCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount),
         sizeof(UBaseType_t[sizeof(uxInitialCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxStaticQueue = pxStaticQueue;
}

void xQueueCreateCountingSemaphoreStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCreateCountingSemaphoreStatic(cmock_call_instance, uxMaxCount, uxInitialCount, pxStaticQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueSemaphoreTake);
  cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSemaphoreTake_CallInstance);
  Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemNext(Mock.xQueueSemaphoreTake_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueSemaphoreTake,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueSemaphoreTake,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSemaphoreTake(CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueueSemaphoreTake_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSemaphoreTake_CALL_INSTANCE));
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemChain(Mock.xQueueSemaphoreTake_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueSemaphoreTake(cmock_call_instance, xQueue, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

TaskHandle_t xQueueGetMutexHolder(QueueHandle_t xSemaphore)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolder);
  cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGetMutexHolder_CallInstance);
  Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemNext(Mock.xQueueGetMutexHolder_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGetMutexHolder,CMockString_xSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGetMutexHolder(CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xSemaphore)
{
  memcpy((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore),
         sizeof(QueueHandle_t[sizeof(xSemaphore) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueGetMutexHolder_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xSemaphore, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolder_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolder_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGetMutexHolder(cmock_call_instance, xSemaphore);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

TaskHandle_t xQueueGetMutexHolderFromISR(QueueHandle_t xSemaphore)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolderFromISR);
  cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGetMutexHolderFromISR_CallInstance);
  Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGetMutexHolderFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGetMutexHolderFromISR,CMockString_xSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGetMutexHolderFromISR(CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xSemaphore)
{
  memcpy((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore),
         sizeof(QueueHandle_t[sizeof(xSemaphore) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueGetMutexHolderFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xSemaphore, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolderFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGetMutexHolderFromISR(cmock_call_instance, xSemaphore);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueTakeMutexRecursive);
  cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueTakeMutexRecursive_CallInstance);
  Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemNext(Mock.xQueueTakeMutexRecursive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueTakeMutexRecursive,CMockString_xMutex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueTakeMutexRecursive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueTakeMutexRecursive(CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xMutex, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex),
         sizeof(QueueHandle_t[sizeof(xMutex) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueueTakeMutexRecursive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xMutex, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueTakeMutexRecursive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueTakeMutexRecursive(cmock_call_instance, xMutex, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGiveMutexRecursive);
  cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGiveMutexRecursive_CallInstance);
  Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemNext(Mock.xQueueGiveMutexRecursive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGiveMutexRecursive,CMockString_xMutex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGiveMutexRecursive(CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xMutex)
{
  memcpy((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex),
         sizeof(QueueHandle_t[sizeof(xMutex) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueGiveMutexRecursive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xMutex, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveMutexRecursive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGiveMutexRecursive(cmock_call_instance, xMutex);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vQueueAddToRegistry(QueueHandle_t xQueue, const char* pcQueueName)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueAddToRegistry);
  cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueAddToRegistry_CallInstance);
  Mock.vQueueAddToRegistry_CallInstance = CMock_Guts_MemNext(Mock.vQueueAddToRegistry_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vQueueAddToRegistry,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vQueueAddToRegistry,CMockString_pcQueueName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcQueueName, pcQueueName, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueAddToRegistry(CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const char* pcQueueName)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pcQueueName = pcQueueName;
}

void vQueueAddToRegistry_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const char* pcQueueName)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueAddToRegistry_CALL_INSTANCE));
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueAddToRegistry_CallInstance = CMock_Guts_MemChain(Mock.vQueueAddToRegistry_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vQueueAddToRegistry(cmock_call_instance, xQueue, pcQueueName);
}

void vQueueUnregisterQueue(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueUnregisterQueue);
  cmock_call_instance = (CMOCK_vQueueUnregisterQueue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueUnregisterQueue_CallInstance);
  Mock.vQueueUnregisterQueue_CallInstance = CMock_Guts_MemNext(Mock.vQueueUnregisterQueue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vQueueUnregisterQueue,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueUnregisterQueue(CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void vQueueUnregisterQueue_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueUnregisterQueue_CALL_INSTANCE));
  CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueUnregisterQueue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueUnregisterQueue_CallInstance = CMock_Guts_MemChain(Mock.vQueueUnregisterQueue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vQueueUnregisterQueue(cmock_call_instance, xQueue);
}

const char* pcQueueGetName(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcQueueGetName);
  cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcQueueGetName_CallInstance);
  Mock.pcQueueGetName_CallInstance = CMock_Guts_MemNext(Mock.pcQueueGetName_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_pcQueueGetName,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcQueueGetName(CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void pcQueueGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcQueueGetName_CALL_INSTANCE));
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcQueueGetName_CallInstance = CMock_Guts_MemChain(Mock.pcQueueGetName_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pcQueueGetName(cmock_call_instance, xQueue);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericCreate);
  cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericCreate_CallInstance);
  Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericCreate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreate,CMockString_uxQueueLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreate,CMockString_uxItemSize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreate,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericCreate(CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength),
         sizeof(UBaseType_t[sizeof(uxQueueLength) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize),
         sizeof(UBaseType_t[sizeof(uxItemSize) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
}

void xQueueGenericCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreate_CALL_INSTANCE));
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGenericCreate(cmock_call_instance, uxQueueLength, uxItemSize, ucQueueType);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

QueueHandle_t xQueueGenericCreateStatic(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, StaticQueue_t* pxStaticQueue, const uint8_t ucQueueType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericCreateStatic);
  cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericCreateStatic_CallInstance);
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericCreateStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_uxQueueLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_uxItemSize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_pucQueueStorage);
    if (cmock_call_instance->Expected_pucQueueStorage == NULL)
      { UNITY_TEST_ASSERT_NULL(pucQueueStorage, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pucQueueStorage, pucQueueStorage, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_pxStaticQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxStaticQueue), (void*)(pxStaticQueue), sizeof(StaticQueue_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericCreateStatic(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, StaticQueue_t* pxStaticQueue, const uint8_t ucQueueType)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength),
         sizeof(UBaseType_t[sizeof(uxQueueLength) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize),
         sizeof(UBaseType_t[sizeof(uxItemSize) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pucQueueStorage = pucQueueStorage;
  cmock_call_instance->Expected_pxStaticQueue = pxStaticQueue;
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
}

void xQueueGenericCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, StaticQueue_t* pxStaticQueue, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGenericCreateStatic(cmock_call_instance, uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

QueueSetHandle_t xQueueCreateSet(const UBaseType_t uxEventQueueLength)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateSet);
  cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateSet_CallInstance);
  Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateSet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateSet,CMockString_uxEventQueueLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxEventQueueLength), (void*)(&uxEventQueueLength), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateSet(CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxEventQueueLength)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxEventQueueLength), (void*)(&uxEventQueueLength),
         sizeof(UBaseType_t[sizeof(uxEventQueueLength) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void xQueueCreateSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxEventQueueLength, QueueSetHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateSet_CALL_INSTANCE));
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateSet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueCreateSet(cmock_call_instance, uxEventQueueLength);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueSetHandle_t[sizeof(cmock_to_return) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueAddToSet);
  cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueAddToSet_CallInstance);
  Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueAddToSet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueAddToSet,CMockString_xQueueOrSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore), sizeof(QueueSetMemberHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueAddToSet,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueAddToSet(CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore),
         sizeof(QueueSetMemberHandle_t[sizeof(xQueueOrSemaphore) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
}

void xQueueAddToSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueAddToSet_CALL_INSTANCE));
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueAddToSet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueAddToSet(cmock_call_instance, xQueueOrSemaphore, xQueueSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xQueueRemoveFromSet(QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueRemoveFromSet);
  cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueRemoveFromSet_CallInstance);
  Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueRemoveFromSet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueRemoveFromSet,CMockString_xQueueOrSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore), sizeof(QueueSetMemberHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueRemoveFromSet,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueRemoveFromSet(CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore),
         sizeof(QueueSetMemberHandle_t[sizeof(xQueueOrSemaphore) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
}

void xQueueRemoveFromSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueRemoveFromSet_CALL_INSTANCE));
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueRemoveFromSet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueRemoveFromSet(cmock_call_instance, xQueueOrSemaphore, xQueueSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

QueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueSelectFromSet);
  cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSelectFromSet_CallInstance);
  Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueSelectFromSet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueSelectFromSet,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueSelectFromSet,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSelectFromSet(CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance, QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xQueueSelectFromSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSet_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueSelectFromSet(cmock_call_instance, xQueueSet, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueSetMemberHandle_t[sizeof(cmock_to_return) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
}

QueueSetMemberHandle_t xQueueSelectFromSetFromISR(QueueSetHandle_t xQueueSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueSelectFromSetFromISR);
  cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSelectFromSetFromISR_CallInstance);
  Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueSelectFromSetFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueSelectFromSetFromISR,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSelectFromSetFromISR(CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance, QueueSetHandle_t xQueueSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
}

void xQueueSelectFromSetFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetHandle_t xQueueSet, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSetFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueSelectFromSetFromISR(cmock_call_instance, xQueueSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueSetMemberHandle_t[sizeof(cmock_to_return) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
}

void vQueueWaitForMessageRestricted(QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueWaitForMessageRestricted);
  cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueWaitForMessageRestricted_CallInstance);
  Mock.vQueueWaitForMessageRestricted_CallInstance = CMock_Guts_MemNext(Mock.vQueueWaitForMessageRestricted_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vQueueWaitForMessageRestricted,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vQueueWaitForMessageRestricted,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vQueueWaitForMessageRestricted,CMockString_xWaitIndefinitely);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueWaitForMessageRestricted(CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely),
         sizeof(BaseType_t[sizeof(xWaitIndefinitely) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vQueueWaitForMessageRestricted_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE));
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueWaitForMessageRestricted_CallInstance = CMock_Guts_MemChain(Mock.vQueueWaitForMessageRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vQueueWaitForMessageRestricted(cmock_call_instance, xQueue, xTicksToWait, xWaitIndefinitely);
}

BaseType_t xQueueGenericReset(QueueHandle_t xQueue, BaseType_t xNewQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericReset);
  cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericReset_CallInstance);
  Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericReset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericReset,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericReset,CMockString_xNewQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xNewQueue), (void*)(&xNewQueue), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericReset(CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, BaseType_t xNewQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xNewQueue), (void*)(&xNewQueue),
         sizeof(BaseType_t[sizeof(xNewQueue) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGenericReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, BaseType_t xNewQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericReset_CALL_INSTANCE));
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericReset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xQueueGenericReset(cmock_call_instance, xQueue, xNewQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vQueueSetQueueNumber(QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueSetQueueNumber);
  cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueSetQueueNumber_CallInstance);
  Mock.vQueueSetQueueNumber_CallInstance = CMock_Guts_MemNext(Mock.vQueueSetQueueNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vQueueSetQueueNumber,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vQueueSetQueueNumber,CMockString_uxQueueNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxQueueNumber), (void*)(&uxQueueNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueSetQueueNumber(CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxQueueNumber), (void*)(&uxQueueNumber),
         sizeof(UBaseType_t[sizeof(uxQueueNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vQueueSetQueueNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueSetQueueNumber_CALL_INSTANCE));
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueSetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.vQueueSetQueueNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vQueueSetQueueNumber(cmock_call_instance, xQueue, uxQueueNumber);
}

UBaseType_t uxQueueGetQueueNumber(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueGetQueueNumber);
  cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueGetQueueNumber_CallInstance);
  Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemNext(Mock.uxQueueGetQueueNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxQueueGetQueueNumber,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueGetQueueNumber(CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void uxQueueGetQueueNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE));
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.uxQueueGetQueueNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxQueueGetQueueNumber(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

uint8_t ucQueueGetQueueType(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ucQueueGetQueueType);
  cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ucQueueGetQueueType_CallInstance);
  Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemNext(Mock.ucQueueGetQueueType_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ucQueueGetQueueType,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ucQueueGetQueueType(CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void ucQueueGetQueueType_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucQueueGetQueueType_CALL_INSTANCE));
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemChain(Mock.ucQueueGetQueueType_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ucQueueGetQueueType(cmock_call_instance, xQueue);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

