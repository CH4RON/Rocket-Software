/* AUTOGENERATED FILE. DO NOT EDIT. */
#include "Mockstream_buffer.h"

#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#include "FreeRTOS.h"
#include "cmock.h"

static const char* CMockString_pucStreamBufferStorageArea = "pucStreamBufferStorageArea";
static const char* CMockString_pvRxData = "pvRxData";
static const char* CMockString_pvTxData = "pvTxData";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxStaticStreamBuffer = "pxStaticStreamBuffer";
static const char* CMockString_ucStreamBufferGetStreamBufferType = "ucStreamBufferGetStreamBufferType";
static const char* CMockString_uxStreamBufferGetStreamBufferNumber = "uxStreamBufferGetStreamBufferNumber";
static const char* CMockString_uxStreamBufferNumber = "uxStreamBufferNumber";
static const char* CMockString_vStreamBufferDelete = "vStreamBufferDelete";
static const char* CMockString_vStreamBufferSetStreamBufferNumber = "vStreamBufferSetStreamBufferNumber";
static const char* CMockString_xBufferLengthBytes = "xBufferLengthBytes";
static const char* CMockString_xBufferSizeBytes = "xBufferSizeBytes";
static const char* CMockString_xDataLengthBytes = "xDataLengthBytes";
static const char* CMockString_xIsMessageBuffer = "xIsMessageBuffer";
static const char* CMockString_xStreamBuffer = "xStreamBuffer";
static const char* CMockString_xStreamBufferBytesAvailable = "xStreamBufferBytesAvailable";
static const char* CMockString_xStreamBufferGenericCreate = "xStreamBufferGenericCreate";
static const char* CMockString_xStreamBufferGenericCreateStatic = "xStreamBufferGenericCreateStatic";
static const char* CMockString_xStreamBufferIsEmpty = "xStreamBufferIsEmpty";
static const char* CMockString_xStreamBufferIsFull = "xStreamBufferIsFull";
static const char* CMockString_xStreamBufferNextMessageLengthBytes = "xStreamBufferNextMessageLengthBytes";
static const char* CMockString_xStreamBufferReceive = "xStreamBufferReceive";
static const char* CMockString_xStreamBufferReceiveCompletedFromISR = "xStreamBufferReceiveCompletedFromISR";
static const char* CMockString_xStreamBufferReceiveFromISR = "xStreamBufferReceiveFromISR";
static const char* CMockString_xStreamBufferReset = "xStreamBufferReset";
static const char* CMockString_xStreamBufferSend = "xStreamBufferSend";
static const char* CMockString_xStreamBufferSendCompletedFromISR = "xStreamBufferSendCompletedFromISR";
static const char* CMockString_xStreamBufferSendFromISR = "xStreamBufferSendFromISR";
static const char* CMockString_xStreamBufferSetTriggerLevel = "xStreamBufferSetTriggerLevel";
static const char* CMockString_xStreamBufferSpacesAvailable = "xStreamBufferSpacesAvailable";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTriggerLevel = "xTriggerLevel";
static const char* CMockString_xTriggerLevelBytes = "xTriggerLevelBytes";

typedef struct _CMOCK_xStreamBufferSend_CALL_INSTANCE {
    UNITY_LINE_TYPE LineNumber;
    size_t ReturnVal;
    StreamBufferHandle_t Expected_xStreamBuffer;
    const void* Expected_pvTxData;
    size_t Expected_xDataLengthBytes;
    TickType_t Expected_xTicksToWait;

} CMOCK_xStreamBufferSend_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  const void* Expected_pvTxData;
  size_t Expected_xDataLengthBytes;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  void* Expected_pvRxData;
  size_t Expected_xBufferLengthBytes;
  TickType_t Expected_xTicksToWait;

} CMOCK_xStreamBufferReceive_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  void* Expected_pvRxData;
  size_t Expected_xBufferLengthBytes;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vStreamBufferDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_vStreamBufferDelete_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferIsFull_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_xStreamBufferIsFull_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_xStreamBufferReset_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  size_t Expected_xTriggerLevel;

} CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  StreamBufferHandle_t ReturnVal;
  size_t Expected_xBufferSizeBytes;
  size_t Expected_xTriggerLevelBytes;
  BaseType_t Expected_xIsMessageBuffer;

} CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  StreamBufferHandle_t ReturnVal;
  size_t Expected_xBufferSizeBytes;
  size_t Expected_xTriggerLevelBytes;
  BaseType_t Expected_xIsMessageBuffer;
  uint8_t* Expected_pucStreamBufferStorageArea;
  StaticStreamBuffer_t* Expected_pxStaticStreamBuffer;

} CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE;

typedef struct _CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  StreamBufferHandle_t Expected_xStreamBuffer;
  UBaseType_t Expected_uxStreamBufferNumber;

} CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE;

typedef struct _CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;

} CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE;

static struct Mockstream_bufferInstance
{
  CMOCK_MEM_INDEX_TYPE xStreamBufferSend_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSendFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReceive_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReceiveFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vStreamBufferDelete_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferIsFull_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferIsEmpty_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReset_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSpacesAvailable_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferBytesAvailable_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSetTriggerLevel_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSendCompletedFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReceiveCompletedFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferGenericCreate_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferGenericCreateStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xStreamBufferNextMessageLengthBytes_CallInstance;
  CMOCK_MEM_INDEX_TYPE vStreamBufferSetStreamBufferNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferGetStreamBufferNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE ucStreamBufferGetStreamBufferType_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockstream_buffer_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xStreamBufferSend_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSendFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSendFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReceive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReceive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReceiveFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vStreamBufferDelete_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vStreamBufferDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferIsFull_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferIsFull);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferIsEmpty_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferIsEmpty);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReset_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSpacesAvailable_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSpacesAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferBytesAvailable_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferBytesAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSetTriggerLevel_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSetTriggerLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSendCompletedFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSendCompletedFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReceiveCompletedFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveCompletedFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferGenericCreate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferGenericCreateStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferNextMessageLengthBytes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferNextMessageLengthBytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vStreamBufferSetStreamBufferNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vStreamBufferSetStreamBufferNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxStreamBufferGetStreamBufferNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferGetStreamBufferNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ucStreamBufferGetStreamBufferType_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ucStreamBufferGetStreamBufferType);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockstream_buffer_Init(void)
{
  Mockstream_buffer_Destroy();
}

void Mockstream_buffer_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSend);
  cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSend_CallInstance);
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSend_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_pvTxData);
    if (cmock_call_instance->Expected_pvTxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTxData, pvTxData, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_xDataLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSend(CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvTxData = pvTxData;
  memcpy((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes),
         sizeof(size_t[sizeof(xDataLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xStreamBufferSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSend_CALL_INSTANCE));
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSend_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferSend(cmock_call_instance, xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

size_t xStreamBufferSendFromISR(StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSendFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSendFromISR_CallInstance);
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSendFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_pvTxData);
    if (cmock_call_instance->Expected_pvTxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTxData, pvTxData, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_xDataLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSendFromISR(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvTxData = pvTxData;
  memcpy((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes),
         sizeof(size_t[sizeof(xDataLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xStreamBufferSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferSendFromISR(cmock_call_instance, xStreamBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

size_t xStreamBufferReceive(StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReceive);
  cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReceive_CallInstance);
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReceive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_pvRxData);
    if (cmock_call_instance->Expected_pvRxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvRxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvRxData, pvRxData, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_xBufferLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReceive(CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvRxData = pvRxData;
  memcpy((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes),
         sizeof(size_t[sizeof(xBufferLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xStreamBufferReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceive_CALL_INSTANCE));
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferReceive(cmock_call_instance, xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

size_t xStreamBufferReceiveFromISR(StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReceiveFromISR_CallInstance);
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReceiveFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_pvRxData);
    if (cmock_call_instance->Expected_pvRxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvRxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvRxData, pvRxData, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_xBufferLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReceiveFromISR(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvRxData = pvRxData;
  memcpy((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes),
         sizeof(size_t[sizeof(xBufferLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xStreamBufferReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferReceiveFromISR(cmock_call_instance, xStreamBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vStreamBufferDelete);
  cmock_call_instance = (CMOCK_vStreamBufferDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vStreamBufferDelete_CallInstance);
  Mock.vStreamBufferDelete_CallInstance = CMock_Guts_MemNext(Mock.vStreamBufferDelete_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferDelete,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vStreamBufferDelete(CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void vStreamBufferDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferDelete_CALL_INSTANCE));
  CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferDelete_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferDelete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vStreamBufferDelete(cmock_call_instance, xStreamBuffer);
}

BaseType_t xStreamBufferIsFull(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferIsFull);
  cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferIsFull_CallInstance);
  Mock.xStreamBufferIsFull_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferIsFull_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferIsFull,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferIsFull(CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferIsFull_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsFull_CALL_INSTANCE));
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsFull_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsFull_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferIsFull(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferIsEmpty);
  cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferIsEmpty_CallInstance);
  Mock.xStreamBufferIsEmpty_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferIsEmpty_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferIsEmpty,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferIsEmpty(CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferIsEmpty_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE));
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsEmpty_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsEmpty_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferIsEmpty(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xStreamBufferReset(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReset);
  cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReset_CallInstance);
  Mock.xStreamBufferReset_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReset_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReset,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReset(CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReset_CALL_INSTANCE));
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReset_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferReset(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSpacesAvailable);
  cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSpacesAvailable_CallInstance);
  Mock.xStreamBufferSpacesAvailable_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSpacesAvailable_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSpacesAvailable,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSpacesAvailable(CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferSpacesAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSpacesAvailable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferSpacesAvailable(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

size_t xStreamBufferBytesAvailable(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferBytesAvailable);
  cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferBytesAvailable_CallInstance);
  Mock.xStreamBufferBytesAvailable_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferBytesAvailable_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferBytesAvailable,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferBytesAvailable(CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferBytesAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferBytesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferBytesAvailable_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferBytesAvailable(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

BaseType_t xStreamBufferSetTriggerLevel(StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSetTriggerLevel);
  cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSetTriggerLevel_CallInstance);
  Mock.xStreamBufferSetTriggerLevel_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSetTriggerLevel_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSetTriggerLevel,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSetTriggerLevel,CMockString_xTriggerLevel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTriggerLevel), (void*)(&xTriggerLevel), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSetTriggerLevel(CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTriggerLevel), (void*)(&xTriggerLevel),
         sizeof(size_t[sizeof(xTriggerLevel) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferSetTriggerLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE));
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSetTriggerLevel_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSetTriggerLevel_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferSetTriggerLevel(cmock_call_instance, xStreamBuffer, xTriggerLevel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xStreamBufferSendCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSendCompletedFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSendCompletedFromISR_CallInstance);
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSendCompletedFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendCompletedFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendCompletedFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSendCompletedFromISR(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xStreamBufferSendCompletedFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferSendCompletedFromISR(cmock_call_instance, xStreamBuffer, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xStreamBufferReceiveCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveCompletedFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance);
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveCompletedFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveCompletedFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReceiveCompletedFromISR(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xStreamBufferReceiveCompletedFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferReceiveCompletedFromISR(cmock_call_instance, xStreamBuffer, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

StreamBufferHandle_t xStreamBufferGenericCreate(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreate);
  cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferGenericCreate_CallInstance);
  Mock.xStreamBufferGenericCreate_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferGenericCreate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreate,CMockString_xBufferSizeBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreate,CMockString_xTriggerLevelBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreate,CMockString_xIsMessageBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferGenericCreate(CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes),
         sizeof(size_t[sizeof(xBufferSizeBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes),
         sizeof(size_t[sizeof(xTriggerLevelBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer),
         sizeof(BaseType_t[sizeof(xIsMessageBuffer) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferGenericCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferGenericCreate(cmock_call_instance, xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(StreamBufferHandle_t[sizeof(cmock_to_return) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

StreamBufferHandle_t xStreamBufferGenericCreateStatic(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, StaticStreamBuffer_t* const pxStaticStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreateStatic);
  cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferGenericCreateStatic_CallInstance);
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferGenericCreateStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_xBufferSizeBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_xTriggerLevelBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_xIsMessageBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_pucStreamBufferStorageArea);
    if (cmock_call_instance->Expected_pucStreamBufferStorageArea == NULL)
      { UNITY_TEST_ASSERT_NULL(pucStreamBufferStorageArea, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pucStreamBufferStorageArea, pucStreamBufferStorageArea, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_pxStaticStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxStaticStreamBuffer), (void*)(pxStaticStreamBuffer), sizeof(StaticStreamBuffer_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferGenericCreateStatic(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, StaticStreamBuffer_t* const pxStaticStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes),
         sizeof(size_t[sizeof(xBufferSizeBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes),
         sizeof(size_t[sizeof(xTriggerLevelBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer),
         sizeof(BaseType_t[sizeof(xIsMessageBuffer) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pucStreamBufferStorageArea = pucStreamBufferStorageArea;
  cmock_call_instance->Expected_pxStaticStreamBuffer = pxStaticStreamBuffer;
}

void xStreamBufferGenericCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, StaticStreamBuffer_t* const pxStaticStreamBuffer, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferGenericCreateStatic(cmock_call_instance, xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(StreamBufferHandle_t[sizeof(cmock_to_return) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

size_t xStreamBufferNextMessageLengthBytes(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferNextMessageLengthBytes);
  cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferNextMessageLengthBytes_CallInstance);
  Mock.xStreamBufferNextMessageLengthBytes_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferNextMessageLengthBytes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferNextMessageLengthBytes,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferNextMessageLengthBytes(CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferNextMessageLengthBytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE));
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferNextMessageLengthBytes_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferNextMessageLengthBytes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xStreamBufferNextMessageLengthBytes(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void vStreamBufferSetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vStreamBufferSetStreamBufferNumber);
  cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vStreamBufferSetStreamBufferNumber_CallInstance);
  Mock.vStreamBufferSetStreamBufferNumber_CallInstance = CMock_Guts_MemNext(Mock.vStreamBufferSetStreamBufferNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferSetStreamBufferNumber,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferSetStreamBufferNumber,CMockString_uxStreamBufferNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxStreamBufferNumber), (void*)(&uxStreamBufferNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vStreamBufferSetStreamBufferNumber(CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxStreamBufferNumber), (void*)(&uxStreamBufferNumber),
         sizeof(UBaseType_t[sizeof(uxStreamBufferNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vStreamBufferSetStreamBufferNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferSetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferSetStreamBufferNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vStreamBufferSetStreamBufferNumber(cmock_call_instance, xStreamBuffer, uxStreamBufferNumber);
}

UBaseType_t uxStreamBufferGetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferGetStreamBufferNumber);
  cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance);
  Mock.uxStreamBufferGetStreamBufferNumber_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGetStreamBufferNumber,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferGetStreamBufferNumber(CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void uxStreamBufferGetStreamBufferNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxStreamBufferGetStreamBufferNumber(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

uint8_t ucStreamBufferGetStreamBufferType(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ucStreamBufferGetStreamBufferType);
  cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ucStreamBufferGetStreamBufferType_CallInstance);
  Mock.ucStreamBufferGetStreamBufferType_CallInstance = CMock_Guts_MemNext(Mock.ucStreamBufferGetStreamBufferType_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ucStreamBufferGetStreamBufferType,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ucStreamBufferGetStreamBufferType(CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void ucStreamBufferGetStreamBufferType_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE));
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucStreamBufferGetStreamBufferType_CallInstance = CMock_Guts_MemChain(Mock.ucStreamBufferGetStreamBufferType_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ucStreamBufferGetStreamBufferType(cmock_call_instance, xStreamBuffer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

