/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockstream_buffer.h"

static const char* CMockString_pucStreamBufferStorageArea = "pucStreamBufferStorageArea";
static const char* CMockString_pvRxData = "pvRxData";
static const char* CMockString_pvTxData = "pvTxData";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxStaticStreamBuffer = "pxStaticStreamBuffer";
static const char* CMockString_ucStreamBufferGetStreamBufferType = "ucStreamBufferGetStreamBufferType";
static const char* CMockString_uxStreamBufferGetStreamBufferNumber = "uxStreamBufferGetStreamBufferNumber";
static const char* CMockString_uxStreamBufferNumber = "uxStreamBufferNumber";
static const char* CMockString_vStreamBufferDelete = "vStreamBufferDelete";
static const char* CMockString_vStreamBufferSetStreamBufferNumber = "vStreamBufferSetStreamBufferNumber";
static const char* CMockString_xBufferLengthBytes = "xBufferLengthBytes";
static const char* CMockString_xBufferSizeBytes = "xBufferSizeBytes";
static const char* CMockString_xDataLengthBytes = "xDataLengthBytes";
static const char* CMockString_xIsMessageBuffer = "xIsMessageBuffer";
static const char* CMockString_xStreamBuffer = "xStreamBuffer";
static const char* CMockString_xStreamBufferBytesAvailable = "xStreamBufferBytesAvailable";
static const char* CMockString_xStreamBufferGenericCreate = "xStreamBufferGenericCreate";
static const char* CMockString_xStreamBufferGenericCreateStatic = "xStreamBufferGenericCreateStatic";
static const char* CMockString_xStreamBufferIsEmpty = "xStreamBufferIsEmpty";
static const char* CMockString_xStreamBufferIsFull = "xStreamBufferIsFull";
static const char* CMockString_xStreamBufferNextMessageLengthBytes = "xStreamBufferNextMessageLengthBytes";
static const char* CMockString_xStreamBufferReceive = "xStreamBufferReceive";
static const char* CMockString_xStreamBufferReceiveCompletedFromISR = "xStreamBufferReceiveCompletedFromISR";
static const char* CMockString_xStreamBufferReceiveFromISR = "xStreamBufferReceiveFromISR";
static const char* CMockString_xStreamBufferReset = "xStreamBufferReset";
static const char* CMockString_xStreamBufferSend = "xStreamBufferSend";
static const char* CMockString_xStreamBufferSendCompletedFromISR = "xStreamBufferSendCompletedFromISR";
static const char* CMockString_xStreamBufferSendFromISR = "xStreamBufferSendFromISR";
static const char* CMockString_xStreamBufferSetTriggerLevel = "xStreamBufferSetTriggerLevel";
static const char* CMockString_xStreamBufferSpacesAvailable = "xStreamBufferSpacesAvailable";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTriggerLevel = "xTriggerLevel";
static const char* CMockString_xTriggerLevelBytes = "xTriggerLevelBytes";

typedef struct _CMOCK_xStreamBufferSend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  const void* Expected_pvTxData;
  size_t Expected_xDataLengthBytes;
  TickType_t Expected_xTicksToWait;
  int Expected_pvTxData_Depth;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_pvTxData;
  char IgnoreArg_xDataLengthBytes;
  char IgnoreArg_xTicksToWait;

} CMOCK_xStreamBufferSend_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  const void* Expected_pvTxData;
  size_t Expected_xDataLengthBytes;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pvTxData_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_pvTxData;
  char IgnoreArg_xDataLengthBytes;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  void* Expected_pvRxData;
  size_t Expected_xBufferLengthBytes;
  TickType_t Expected_xTicksToWait;
  int Expected_pvRxData_Depth;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_pvRxData;
  char IgnoreArg_xBufferLengthBytes;
  char IgnoreArg_xTicksToWait;

} CMOCK_xStreamBufferReceive_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  void* Expected_pvRxData;
  size_t Expected_xBufferLengthBytes;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pvRxData_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_pvRxData;
  char IgnoreArg_xBufferLengthBytes;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vStreamBufferDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_vStreamBufferDelete_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferIsFull_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_xStreamBufferIsFull_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_xStreamBufferReset_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  size_t Expected_xTriggerLevel;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_xTriggerLevel;

} CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  StreamBufferHandle_t ReturnVal;
  size_t Expected_xBufferSizeBytes;
  size_t Expected_xTriggerLevelBytes;
  BaseType_t Expected_xIsMessageBuffer;
  char IgnoreArg_xBufferSizeBytes;
  char IgnoreArg_xTriggerLevelBytes;
  char IgnoreArg_xIsMessageBuffer;

} CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  StreamBufferHandle_t ReturnVal;
  size_t Expected_xBufferSizeBytes;
  size_t Expected_xTriggerLevelBytes;
  BaseType_t Expected_xIsMessageBuffer;
  uint8_t* Expected_pucStreamBufferStorageArea;
  StaticStreamBuffer_t* Expected_pxStaticStreamBuffer;
  int Expected_pucStreamBufferStorageArea_Depth;
  int Expected_pxStaticStreamBuffer_Depth;
  char IgnoreArg_xBufferSizeBytes;
  char IgnoreArg_xTriggerLevelBytes;
  char IgnoreArg_xIsMessageBuffer;
  char IgnoreArg_pucStreamBufferStorageArea;
  char IgnoreArg_pxStaticStreamBuffer;

} CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE;

typedef struct _CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  StreamBufferHandle_t Expected_xStreamBuffer;
  UBaseType_t Expected_uxStreamBufferNumber;
  char IgnoreArg_xStreamBuffer;
  char IgnoreArg_uxStreamBufferNumber;

} CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE;

typedef struct _CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint8_t ReturnVal;
  StreamBufferHandle_t Expected_xStreamBuffer;
  char IgnoreArg_xStreamBuffer;

} CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE;

static struct Mockstream_bufferInstance
{
  char xStreamBufferSend_IgnoreBool;
  size_t xStreamBufferSend_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSend_CallInstance;
  char xStreamBufferSendFromISR_IgnoreBool;
  size_t xStreamBufferSendFromISR_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSendFromISR_CallInstance;
  char xStreamBufferReceive_IgnoreBool;
  size_t xStreamBufferReceive_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReceive_CallInstance;
  char xStreamBufferReceiveFromISR_IgnoreBool;
  size_t xStreamBufferReceiveFromISR_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReceiveFromISR_CallInstance;
  char vStreamBufferDelete_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE vStreamBufferDelete_CallInstance;
  char xStreamBufferIsFull_IgnoreBool;
  BaseType_t xStreamBufferIsFull_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferIsFull_CallInstance;
  char xStreamBufferIsEmpty_IgnoreBool;
  BaseType_t xStreamBufferIsEmpty_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferIsEmpty_CallInstance;
  char xStreamBufferReset_IgnoreBool;
  BaseType_t xStreamBufferReset_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReset_CallInstance;
  char xStreamBufferSpacesAvailable_IgnoreBool;
  size_t xStreamBufferSpacesAvailable_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSpacesAvailable_CallInstance;
  char xStreamBufferBytesAvailable_IgnoreBool;
  size_t xStreamBufferBytesAvailable_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferBytesAvailable_CallInstance;
  char xStreamBufferSetTriggerLevel_IgnoreBool;
  BaseType_t xStreamBufferSetTriggerLevel_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSetTriggerLevel_CallInstance;
  char xStreamBufferSendCompletedFromISR_IgnoreBool;
  BaseType_t xStreamBufferSendCompletedFromISR_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferSendCompletedFromISR_CallInstance;
  char xStreamBufferReceiveCompletedFromISR_IgnoreBool;
  BaseType_t xStreamBufferReceiveCompletedFromISR_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferReceiveCompletedFromISR_CallInstance;
  char xStreamBufferGenericCreate_IgnoreBool;
  StreamBufferHandle_t xStreamBufferGenericCreate_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferGenericCreate_CallInstance;
  char xStreamBufferGenericCreateStatic_IgnoreBool;
  StreamBufferHandle_t xStreamBufferGenericCreateStatic_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferGenericCreateStatic_CallInstance;
  char xStreamBufferNextMessageLengthBytes_IgnoreBool;
  size_t xStreamBufferNextMessageLengthBytes_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xStreamBufferNextMessageLengthBytes_CallInstance;
  char vStreamBufferSetStreamBufferNumber_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE vStreamBufferSetStreamBufferNumber_CallInstance;
  char uxStreamBufferGetStreamBufferNumber_IgnoreBool;
  UBaseType_t uxStreamBufferGetStreamBufferNumber_FinalReturn;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferGetStreamBufferNumber_CallInstance;
  char ucStreamBufferGetStreamBufferType_IgnoreBool;
  uint8_t ucStreamBufferGetStreamBufferType_FinalReturn;
  CMOCK_MEM_INDEX_TYPE ucStreamBufferGetStreamBufferType_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockstream_buffer_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xStreamBufferSend_CallInstance;
  if (Mock.xStreamBufferSend_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSendFromISR_CallInstance;
  if (Mock.xStreamBufferSendFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSendFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReceive_CallInstance;
  if (Mock.xStreamBufferReceive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReceive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReceiveFromISR_CallInstance;
  if (Mock.xStreamBufferReceiveFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vStreamBufferDelete_CallInstance;
  if (Mock.vStreamBufferDelete_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vStreamBufferDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferIsFull_CallInstance;
  if (Mock.xStreamBufferIsFull_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferIsFull);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferIsEmpty_CallInstance;
  if (Mock.xStreamBufferIsEmpty_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferIsEmpty);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReset_CallInstance;
  if (Mock.xStreamBufferReset_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSpacesAvailable_CallInstance;
  if (Mock.xStreamBufferSpacesAvailable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSpacesAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferBytesAvailable_CallInstance;
  if (Mock.xStreamBufferBytesAvailable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferBytesAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSetTriggerLevel_CallInstance;
  if (Mock.xStreamBufferSetTriggerLevel_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSetTriggerLevel);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferSendCompletedFromISR_CallInstance;
  if (Mock.xStreamBufferSendCompletedFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferSendCompletedFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferReceiveCompletedFromISR_CallInstance;
  if (Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveCompletedFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferGenericCreate_CallInstance;
  if (Mock.xStreamBufferGenericCreate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferGenericCreateStatic_CallInstance;
  if (Mock.xStreamBufferGenericCreateStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xStreamBufferNextMessageLengthBytes_CallInstance;
  if (Mock.xStreamBufferNextMessageLengthBytes_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferNextMessageLengthBytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vStreamBufferSetStreamBufferNumber_CallInstance;
  if (Mock.vStreamBufferSetStreamBufferNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vStreamBufferSetStreamBufferNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxStreamBufferGetStreamBufferNumber_CallInstance;
  if (Mock.uxStreamBufferGetStreamBufferNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferGetStreamBufferNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ucStreamBufferGetStreamBufferType_CallInstance;
  if (Mock.ucStreamBufferGetStreamBufferType_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ucStreamBufferGetStreamBufferType);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockstream_buffer_Init(void)
{
  Mockstream_buffer_Destroy();
}

void Mockstream_buffer_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSend);
  cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSend_CallInstance);
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSend_CallInstance);
  if (Mock.xStreamBufferSend_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferSend_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferSend_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvTxData)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_pvTxData);
    if (cmock_call_instance->Expected_pvTxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTxData, pvTxData, cmock_call_instance->Expected_pvTxData_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xDataLengthBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_xDataLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSend,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSend(CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, int pvTxData_Depth, size_t xDataLengthBytes, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  cmock_call_instance->Expected_pvTxData = pvTxData;
  cmock_call_instance->Expected_pvTxData_Depth = pvTxData_Depth;
  cmock_call_instance->IgnoreArg_pvTxData = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes),
         sizeof(size_t[sizeof(xDataLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xDataLengthBytes = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xStreamBufferSend_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSend_CALL_INSTANCE));
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSend_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferSend_IgnoreBool = (char)1;
}

void xStreamBufferSend_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSend_CALL_INSTANCE));
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSend_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSend_CALL_INSTANCE));
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSend_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSend(cmock_call_instance, xStreamBuffer, pvTxData, 1, xDataLengthBytes, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferSend_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, int pvTxData_Depth, size_t xDataLengthBytes, TickType_t xTicksToWait, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSend_CALL_INSTANCE));
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSend_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSend_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSend(cmock_call_instance, xStreamBuffer, pvTxData, pvTxData_Depth, xDataLengthBytes, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferSend_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferSend_CMockIgnoreArg_pvTxData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvTxData = 1;
}

void xStreamBufferSend_CMockIgnoreArg_xDataLengthBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xDataLengthBytes = 1;
}

void xStreamBufferSend_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

size_t xStreamBufferSendFromISR(StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSendFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSendFromISR_CallInstance);
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSendFromISR_CallInstance);
  if (Mock.xStreamBufferSendFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferSendFromISR_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferSendFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvTxData)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_pvTxData);
    if (cmock_call_instance->Expected_pvTxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTxData, pvTxData, cmock_call_instance->Expected_pvTxData_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xDataLengthBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_xDataLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSendFromISR(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, int pvTxData_Depth, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  cmock_call_instance->Expected_pvTxData = pvTxData;
  cmock_call_instance->Expected_pvTxData_Depth = pvTxData_Depth;
  cmock_call_instance->IgnoreArg_pvTxData = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xDataLengthBytes), (void*)(&xDataLengthBytes),
         sizeof(size_t[sizeof(xDataLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xDataLengthBytes = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
}

void xStreamBufferSendFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferSendFromISR_IgnoreBool = (char)1;
}

void xStreamBufferSendFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSendFromISR(cmock_call_instance, xStreamBuffer, pvTxData, 1, xDataLengthBytes, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferSendFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, const void* pvTxData, int pvTxData_Depth, size_t xDataLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSendFromISR(cmock_call_instance, xStreamBuffer, pvTxData, pvTxData_Depth, xDataLengthBytes, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferSendFromISR_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferSendFromISR_CMockIgnoreArg_pvTxData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvTxData = 1;
}

void xStreamBufferSendFromISR_CMockIgnoreArg_xDataLengthBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xDataLengthBytes = 1;
}

void xStreamBufferSendFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

size_t xStreamBufferReceive(StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReceive);
  cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReceive_CallInstance);
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReceive_CallInstance);
  if (Mock.xStreamBufferReceive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferReceive_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferReceive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvRxData)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_pvRxData);
    if (cmock_call_instance->Expected_pvRxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvRxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvRxData, pvRxData, cmock_call_instance->Expected_pvRxData_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xBufferLengthBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_xBufferLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReceive(CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, void* pvRxData, int pvRxData_Depth, size_t xBufferLengthBytes, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  cmock_call_instance->Expected_pvRxData = pvRxData;
  cmock_call_instance->Expected_pvRxData_Depth = pvRxData_Depth;
  cmock_call_instance->IgnoreArg_pvRxData = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes),
         sizeof(size_t[sizeof(xBufferLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xBufferLengthBytes = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xStreamBufferReceive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceive_CALL_INSTANCE));
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceive_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferReceive_IgnoreBool = (char)1;
}

void xStreamBufferReceive_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceive_CALL_INSTANCE));
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceive_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceive_CALL_INSTANCE));
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceive_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReceive(cmock_call_instance, xStreamBuffer, pvRxData, 1, xBufferLengthBytes, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferReceive_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, void* pvRxData, int pvRxData_Depth, size_t xBufferLengthBytes, TickType_t xTicksToWait, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceive_CALL_INSTANCE));
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceive_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceive_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReceive(cmock_call_instance, xStreamBuffer, pvRxData, pvRxData_Depth, xBufferLengthBytes, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferReceive_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferReceive_CMockIgnoreArg_pvRxData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvRxData = 1;
}

void xStreamBufferReceive_CMockIgnoreArg_xBufferLengthBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xBufferLengthBytes = 1;
}

void xStreamBufferReceive_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

size_t xStreamBufferReceiveFromISR(StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReceiveFromISR_CallInstance);
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReceiveFromISR_CallInstance);
  if (Mock.xStreamBufferReceiveFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferReceiveFromISR_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferReceiveFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvRxData)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_pvRxData);
    if (cmock_call_instance->Expected_pvRxData == NULL)
      { UNITY_TEST_ASSERT_NULL(pvRxData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvRxData, pvRxData, cmock_call_instance->Expected_pvRxData_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xBufferLengthBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_xBufferLengthBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReceiveFromISR(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, void* pvRxData, int pvRxData_Depth, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  cmock_call_instance->Expected_pvRxData = pvRxData;
  cmock_call_instance->Expected_pvRxData_Depth = pvRxData_Depth;
  cmock_call_instance->IgnoreArg_pvRxData = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xBufferLengthBytes), (void*)(&xBufferLengthBytes),
         sizeof(size_t[sizeof(xBufferLengthBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xBufferLengthBytes = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
}

void xStreamBufferReceiveFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferReceiveFromISR_IgnoreBool = (char)1;
}

void xStreamBufferReceiveFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, void* pvRxData, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReceiveFromISR(cmock_call_instance, xStreamBuffer, pvRxData, 1, xBufferLengthBytes, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferReceiveFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, void* pvRxData, int pvRxData_Depth, size_t xBufferLengthBytes, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReceiveFromISR(cmock_call_instance, xStreamBuffer, pvRxData, pvRxData_Depth, xBufferLengthBytes, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferReceiveFromISR_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferReceiveFromISR_CMockIgnoreArg_pvRxData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvRxData = 1;
}

void xStreamBufferReceiveFromISR_CMockIgnoreArg_xBufferLengthBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xBufferLengthBytes = 1;
}

void xStreamBufferReceiveFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vStreamBufferDelete);
  cmock_call_instance = (CMOCK_vStreamBufferDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vStreamBufferDelete_CallInstance);
  Mock.vStreamBufferDelete_CallInstance = CMock_Guts_MemNext(Mock.vStreamBufferDelete_CallInstance);
  if (Mock.vStreamBufferDelete_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferDelete,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vStreamBufferDelete(CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void vStreamBufferDelete_CMockIgnore(void)
{
  Mock.vStreamBufferDelete_IgnoreBool = (char)1;
}

void vStreamBufferDelete_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferDelete_CALL_INSTANCE));
  CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferDelete_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferDelete_CallInstance, cmock_guts_index);
  Mock.vStreamBufferDelete_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vStreamBufferDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferDelete_CALL_INSTANCE));
  CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferDelete_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferDelete_CallInstance, cmock_guts_index);
  Mock.vStreamBufferDelete_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vStreamBufferDelete(cmock_call_instance, xStreamBuffer);
}

void vStreamBufferDelete_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vStreamBufferDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferDelete_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

BaseType_t xStreamBufferIsFull(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferIsFull);
  cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferIsFull_CallInstance);
  Mock.xStreamBufferIsFull_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferIsFull_CallInstance);
  if (Mock.xStreamBufferIsFull_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferIsFull_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferIsFull_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferIsFull,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferIsFull(CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void xStreamBufferIsFull_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsFull_CALL_INSTANCE));
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsFull_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsFull_CallInstance, cmock_guts_index);
  Mock.xStreamBufferIsFull_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferIsFull_IgnoreBool = (char)1;
}

void xStreamBufferIsFull_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsFull_CALL_INSTANCE));
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsFull_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsFull_CallInstance, cmock_guts_index);
  Mock.xStreamBufferIsFull_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferIsFull_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsFull_CALL_INSTANCE));
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsFull_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsFull_CallInstance, cmock_guts_index);
  Mock.xStreamBufferIsFull_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferIsFull(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferIsFull_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferIsFull_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsFull_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferIsFull_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferIsEmpty);
  cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferIsEmpty_CallInstance);
  Mock.xStreamBufferIsEmpty_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferIsEmpty_CallInstance);
  if (Mock.xStreamBufferIsEmpty_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferIsEmpty_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferIsEmpty_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferIsEmpty,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferIsEmpty(CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void xStreamBufferIsEmpty_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE));
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsEmpty_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsEmpty_CallInstance, cmock_guts_index);
  Mock.xStreamBufferIsEmpty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferIsEmpty_IgnoreBool = (char)1;
}

void xStreamBufferIsEmpty_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE));
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsEmpty_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsEmpty_CallInstance, cmock_guts_index);
  Mock.xStreamBufferIsEmpty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferIsEmpty_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE));
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferIsEmpty_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferIsEmpty_CallInstance, cmock_guts_index);
  Mock.xStreamBufferIsEmpty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferIsEmpty(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferIsEmpty_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferIsEmpty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferIsEmpty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

BaseType_t xStreamBufferReset(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReset);
  cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReset_CallInstance);
  Mock.xStreamBufferReset_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReset_CallInstance);
  if (Mock.xStreamBufferReset_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferReset_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferReset_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReset,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReset(CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void xStreamBufferReset_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReset_CALL_INSTANCE));
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReset_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReset_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferReset_IgnoreBool = (char)1;
}

void xStreamBufferReset_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReset_CALL_INSTANCE));
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReset_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReset_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReset_CALL_INSTANCE));
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReset_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReset_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReset(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferReset_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReset_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSpacesAvailable);
  cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSpacesAvailable_CallInstance);
  Mock.xStreamBufferSpacesAvailable_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSpacesAvailable_CallInstance);
  if (Mock.xStreamBufferSpacesAvailable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferSpacesAvailable_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferSpacesAvailable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSpacesAvailable,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSpacesAvailable(CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void xStreamBufferSpacesAvailable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSpacesAvailable_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSpacesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferSpacesAvailable_IgnoreBool = (char)1;
}

void xStreamBufferSpacesAvailable_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSpacesAvailable_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSpacesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferSpacesAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSpacesAvailable_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSpacesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSpacesAvailable(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferSpacesAvailable_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSpacesAvailable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

size_t xStreamBufferBytesAvailable(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferBytesAvailable);
  cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferBytesAvailable_CallInstance);
  Mock.xStreamBufferBytesAvailable_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferBytesAvailable_CallInstance);
  if (Mock.xStreamBufferBytesAvailable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferBytesAvailable_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferBytesAvailable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferBytesAvailable,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferBytesAvailable(CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void xStreamBufferBytesAvailable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferBytesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferBytesAvailable_CallInstance, cmock_guts_index);
  Mock.xStreamBufferBytesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferBytesAvailable_IgnoreBool = (char)1;
}

void xStreamBufferBytesAvailable_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferBytesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferBytesAvailable_CallInstance, cmock_guts_index);
  Mock.xStreamBufferBytesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferBytesAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE));
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferBytesAvailable_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferBytesAvailable_CallInstance, cmock_guts_index);
  Mock.xStreamBufferBytesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferBytesAvailable(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferBytesAvailable_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferBytesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferBytesAvailable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

BaseType_t xStreamBufferSetTriggerLevel(StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSetTriggerLevel);
  cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSetTriggerLevel_CallInstance);
  Mock.xStreamBufferSetTriggerLevel_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSetTriggerLevel_CallInstance);
  if (Mock.xStreamBufferSetTriggerLevel_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferSetTriggerLevel_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferSetTriggerLevel_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSetTriggerLevel,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTriggerLevel)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSetTriggerLevel,CMockString_xTriggerLevel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTriggerLevel), (void*)(&xTriggerLevel), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSetTriggerLevel(CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTriggerLevel), (void*)(&xTriggerLevel),
         sizeof(size_t[sizeof(xTriggerLevel) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTriggerLevel = 0;
}

void xStreamBufferSetTriggerLevel_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE));
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSetTriggerLevel_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSetTriggerLevel_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSetTriggerLevel_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferSetTriggerLevel_IgnoreBool = (char)1;
}

void xStreamBufferSetTriggerLevel_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE));
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSetTriggerLevel_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSetTriggerLevel_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSetTriggerLevel_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferSetTriggerLevel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE));
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSetTriggerLevel_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSetTriggerLevel_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSetTriggerLevel_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSetTriggerLevel(cmock_call_instance, xStreamBuffer, xTriggerLevel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferSetTriggerLevel_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSetTriggerLevel_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferSetTriggerLevel_CMockIgnoreArg_xTriggerLevel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSetTriggerLevel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSetTriggerLevel_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTriggerLevel = 1;
}

BaseType_t xStreamBufferSendCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferSendCompletedFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferSendCompletedFromISR_CallInstance);
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferSendCompletedFromISR_CallInstance);
  if (Mock.xStreamBufferSendCompletedFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferSendCompletedFromISR_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferSendCompletedFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendCompletedFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferSendCompletedFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferSendCompletedFromISR(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
}

void xStreamBufferSendCompletedFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferSendCompletedFromISR_IgnoreBool = (char)1;
}

void xStreamBufferSendCompletedFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferSendCompletedFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSendCompletedFromISR(cmock_call_instance, xStreamBuffer, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferSendCompletedFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferSendCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferSendCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferSendCompletedFromISR(cmock_call_instance, xStreamBuffer, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferSendCompletedFromISR_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferSendCompletedFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferSendCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferSendCompletedFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

BaseType_t xStreamBufferReceiveCompletedFromISR(StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferReceiveCompletedFromISR);
  cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance);
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance);
  if (Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferReceiveCompletedFromISR_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferReceiveCompletedFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveCompletedFromISR,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferReceiveCompletedFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferReceiveCompletedFromISR(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
}

void xStreamBufferReceiveCompletedFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool = (char)1;
}

void xStreamBufferReceiveCompletedFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferReceiveCompletedFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReceiveCompletedFromISR(cmock_call_instance, xStreamBuffer, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferReceiveCompletedFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE));
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferReceiveCompletedFromISR_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance, cmock_guts_index);
  Mock.xStreamBufferReceiveCompletedFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferReceiveCompletedFromISR(cmock_call_instance, xStreamBuffer, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferReceiveCompletedFromISR_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void xStreamBufferReceiveCompletedFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferReceiveCompletedFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferReceiveCompletedFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

StreamBufferHandle_t xStreamBufferGenericCreate(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreate);
  cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferGenericCreate_CallInstance);
  Mock.xStreamBufferGenericCreate_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferGenericCreate_CallInstance);
  if (Mock.xStreamBufferGenericCreate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferGenericCreate_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferGenericCreate_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(StreamBufferHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xBufferSizeBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreate,CMockString_xBufferSizeBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTriggerLevelBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreate,CMockString_xTriggerLevelBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xIsMessageBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreate,CMockString_xIsMessageBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferGenericCreate(CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes),
         sizeof(size_t[sizeof(xBufferSizeBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xBufferSizeBytes = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes),
         sizeof(size_t[sizeof(xTriggerLevelBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTriggerLevelBytes = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer),
         sizeof(BaseType_t[sizeof(xIsMessageBuffer) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xIsMessageBuffer = 0;
}

void xStreamBufferGenericCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreate_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferGenericCreate_IgnoreBool = (char)1;
}

void xStreamBufferGenericCreate_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreate_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferGenericCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreate_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferGenericCreate(cmock_call_instance, xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(StreamBufferHandle_t[sizeof(cmock_to_return) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferGenericCreate_CMockIgnoreArg_xBufferSizeBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xBufferSizeBytes = 1;
}

void xStreamBufferGenericCreate_CMockIgnoreArg_xTriggerLevelBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTriggerLevelBytes = 1;
}

void xStreamBufferGenericCreate_CMockIgnoreArg_xIsMessageBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xIsMessageBuffer = 1;
}

StreamBufferHandle_t xStreamBufferGenericCreateStatic(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, StaticStreamBuffer_t* const pxStaticStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferGenericCreateStatic);
  cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferGenericCreateStatic_CallInstance);
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferGenericCreateStatic_CallInstance);
  if (Mock.xStreamBufferGenericCreateStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferGenericCreateStatic_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferGenericCreateStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(StreamBufferHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xBufferSizeBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_xBufferSizeBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTriggerLevelBytes)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_xTriggerLevelBytes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xIsMessageBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_xIsMessageBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pucStreamBufferStorageArea)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_pucStreamBufferStorageArea);
    if (cmock_call_instance->Expected_pucStreamBufferStorageArea == NULL)
      { UNITY_TEST_ASSERT_NULL(pucStreamBufferStorageArea, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pucStreamBufferStorageArea, pucStreamBufferStorageArea, cmock_call_instance->Expected_pucStreamBufferStorageArea_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxStaticStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferGenericCreateStatic,CMockString_pxStaticStreamBuffer);
    if (cmock_call_instance->Expected_pxStaticStreamBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxStaticStreamBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxStaticStreamBuffer), (void*)(pxStaticStreamBuffer), sizeof(StaticStreamBuffer_t), cmock_call_instance->Expected_pxStaticStreamBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferGenericCreateStatic(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, int pucStreamBufferStorageArea_Depth, StaticStreamBuffer_t* const pxStaticStreamBuffer, int pxStaticStreamBuffer_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xBufferSizeBytes), (void*)(&xBufferSizeBytes),
         sizeof(size_t[sizeof(xBufferSizeBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xBufferSizeBytes = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTriggerLevelBytes), (void*)(&xTriggerLevelBytes),
         sizeof(size_t[sizeof(xTriggerLevelBytes) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTriggerLevelBytes = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xIsMessageBuffer), (void*)(&xIsMessageBuffer),
         sizeof(BaseType_t[sizeof(xIsMessageBuffer) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xIsMessageBuffer = 0;
  cmock_call_instance->Expected_pucStreamBufferStorageArea = pucStreamBufferStorageArea;
  cmock_call_instance->Expected_pucStreamBufferStorageArea_Depth = pucStreamBufferStorageArea_Depth;
  cmock_call_instance->IgnoreArg_pucStreamBufferStorageArea = 0;
  cmock_call_instance->Expected_pxStaticStreamBuffer = pxStaticStreamBuffer;
  cmock_call_instance->Expected_pxStaticStreamBuffer_Depth = pxStaticStreamBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxStaticStreamBuffer = 0;
}

void xStreamBufferGenericCreateStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferGenericCreateStatic_IgnoreBool = (char)1;
}

void xStreamBufferGenericCreateStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferGenericCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, StaticStreamBuffer_t* const pxStaticStreamBuffer, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferGenericCreateStatic(cmock_call_instance, xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, 1, pxStaticStreamBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(StreamBufferHandle_t[sizeof(cmock_to_return) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
}

void xStreamBufferGenericCreateStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer, uint8_t* const pucStreamBufferStorageArea, int pucStreamBufferStorageArea_Depth, StaticStreamBuffer_t* const pxStaticStreamBuffer, int pxStaticStreamBuffer_Depth, StreamBufferHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xStreamBufferGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferGenericCreateStatic(cmock_call_instance, xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pucStreamBufferStorageArea_Depth, pxStaticStreamBuffer, pxStaticStreamBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferGenericCreateStatic_CMockIgnoreArg_xBufferSizeBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xBufferSizeBytes = 1;
}

void xStreamBufferGenericCreateStatic_CMockIgnoreArg_xTriggerLevelBytes(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTriggerLevelBytes = 1;
}

void xStreamBufferGenericCreateStatic_CMockIgnoreArg_xIsMessageBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xIsMessageBuffer = 1;
}

void xStreamBufferGenericCreateStatic_CMockIgnoreArg_pucStreamBufferStorageArea(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pucStreamBufferStorageArea = 1;
}

void xStreamBufferGenericCreateStatic_CMockIgnoreArg_pxStaticStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxStaticStreamBuffer = 1;
}

size_t xStreamBufferNextMessageLengthBytes(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferNextMessageLengthBytes);
  cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferNextMessageLengthBytes_CallInstance);
  Mock.xStreamBufferNextMessageLengthBytes_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferNextMessageLengthBytes_CallInstance);
  if (Mock.xStreamBufferNextMessageLengthBytes_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferNextMessageLengthBytes_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferNextMessageLengthBytes_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferNextMessageLengthBytes,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferNextMessageLengthBytes(CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void xStreamBufferNextMessageLengthBytes_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE));
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferNextMessageLengthBytes_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferNextMessageLengthBytes_CallInstance, cmock_guts_index);
  Mock.xStreamBufferNextMessageLengthBytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferNextMessageLengthBytes_IgnoreBool = (char)1;
}

void xStreamBufferNextMessageLengthBytes_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE));
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferNextMessageLengthBytes_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferNextMessageLengthBytes_CallInstance, cmock_guts_index);
  Mock.xStreamBufferNextMessageLengthBytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferNextMessageLengthBytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE));
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferNextMessageLengthBytes_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferNextMessageLengthBytes_CallInstance, cmock_guts_index);
  Mock.xStreamBufferNextMessageLengthBytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferNextMessageLengthBytes(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void xStreamBufferNextMessageLengthBytes_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferNextMessageLengthBytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferNextMessageLengthBytes_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void vStreamBufferSetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vStreamBufferSetStreamBufferNumber);
  cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vStreamBufferSetStreamBufferNumber_CallInstance);
  Mock.vStreamBufferSetStreamBufferNumber_CallInstance = CMock_Guts_MemNext(Mock.vStreamBufferSetStreamBufferNumber_CallInstance);
  if (Mock.vStreamBufferSetStreamBufferNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferSetStreamBufferNumber,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxStreamBufferNumber)
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferSetStreamBufferNumber,CMockString_uxStreamBufferNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxStreamBufferNumber), (void*)(&uxStreamBufferNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vStreamBufferSetStreamBufferNumber(CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxStreamBufferNumber), (void*)(&uxStreamBufferNumber),
         sizeof(UBaseType_t[sizeof(uxStreamBufferNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxStreamBufferNumber = 0;
}

void vStreamBufferSetStreamBufferNumber_CMockIgnore(void)
{
  Mock.vStreamBufferSetStreamBufferNumber_IgnoreBool = (char)1;
}

void vStreamBufferSetStreamBufferNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferSetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferSetStreamBufferNumber_CallInstance, cmock_guts_index);
  Mock.vStreamBufferSetStreamBufferNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vStreamBufferSetStreamBufferNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferSetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferSetStreamBufferNumber_CallInstance, cmock_guts_index);
  Mock.vStreamBufferSetStreamBufferNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vStreamBufferSetStreamBufferNumber(cmock_call_instance, xStreamBuffer, uxStreamBufferNumber);
}

void vStreamBufferSetStreamBufferNumber_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferSetStreamBufferNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

void vStreamBufferSetStreamBufferNumber_CMockIgnoreArg_uxStreamBufferNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferSetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferSetStreamBufferNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxStreamBufferNumber = 1;
}

UBaseType_t uxStreamBufferGetStreamBufferNumber(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferGetStreamBufferNumber);
  cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance);
  Mock.uxStreamBufferGetStreamBufferNumber_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance);
  if (Mock.uxStreamBufferGetStreamBufferNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferGetStreamBufferNumber_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferGetStreamBufferNumber_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGetStreamBufferNumber,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferGetStreamBufferNumber(CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void uxStreamBufferGetStreamBufferNumber_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetStreamBufferNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferGetStreamBufferNumber_IgnoreBool = (char)1;
}

void uxStreamBufferGetStreamBufferNumber_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetStreamBufferNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferGetStreamBufferNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetStreamBufferNumber_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetStreamBufferNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetStreamBufferNumber(cmock_call_instance, xStreamBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxStreamBufferGetStreamBufferNumber_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetStreamBufferNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetStreamBufferNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

uint8_t ucStreamBufferGetStreamBufferType(StreamBufferHandle_t xStreamBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ucStreamBufferGetStreamBufferType);
  cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ucStreamBufferGetStreamBufferType_CallInstance);
  Mock.ucStreamBufferGetStreamBufferType_CallInstance = CMock_Guts_MemNext(Mock.ucStreamBufferGetStreamBufferType_CallInstance);
  if (Mock.ucStreamBufferGetStreamBufferType_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ucStreamBufferGetStreamBufferType_FinalReturn;
    Mock.ucStreamBufferGetStreamBufferType_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xStreamBuffer)
  {
    UNITY_SET_DETAILS(CMockString_ucStreamBufferGetStreamBufferType,CMockString_xStreamBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer), sizeof(StreamBufferHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ucStreamBufferGetStreamBufferType(CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance, StreamBufferHandle_t xStreamBuffer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xStreamBuffer), (void*)(&xStreamBuffer),
         sizeof(StreamBufferHandle_t[sizeof(xStreamBuffer) == sizeof(StreamBufferHandle_t) ? 1 : -1])); /* add StreamBufferHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xStreamBuffer = 0;
}

void ucStreamBufferGetStreamBufferType_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE));
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucStreamBufferGetStreamBufferType_CallInstance = CMock_Guts_MemChain(Mock.ucStreamBufferGetStreamBufferType_CallInstance, cmock_guts_index);
  Mock.ucStreamBufferGetStreamBufferType_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ucStreamBufferGetStreamBufferType_IgnoreBool = (char)1;
}

void ucStreamBufferGetStreamBufferType_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE));
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucStreamBufferGetStreamBufferType_CallInstance = CMock_Guts_MemChain(Mock.ucStreamBufferGetStreamBufferType_CallInstance, cmock_guts_index);
  Mock.ucStreamBufferGetStreamBufferType_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ucStreamBufferGetStreamBufferType_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBufferHandle_t xStreamBuffer, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE));
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucStreamBufferGetStreamBufferType_CallInstance = CMock_Guts_MemChain(Mock.ucStreamBufferGetStreamBufferType_CallInstance, cmock_guts_index);
  Mock.ucStreamBufferGetStreamBufferType_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ucStreamBufferGetStreamBufferType(cmock_call_instance, xStreamBuffer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ucStreamBufferGetStreamBufferType_CMockIgnoreArg_xStreamBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucStreamBufferGetStreamBufferType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ucStreamBufferGetStreamBufferType_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xStreamBuffer = 1;
}

