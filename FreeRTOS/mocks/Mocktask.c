/* AUTOGENERATED FILE. DO NOT EDIT. */
#include "FreeRTOS.h"
#include "Mocktask.h"

#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#include "cmock.h"

static const char* CMockString_eAction = "eAction";
static const char* CMockString_eState = "eState";
static const char* CMockString_eTaskConfirmSleepModeStatus = "eTaskConfirmSleepModeStatus";
static const char* CMockString_eTaskGetState = "eTaskGetState";
static const char* CMockString_pcName = "pcName";
static const char* CMockString_pcNameToQuery = "pcNameToQuery";
static const char* CMockString_pcTaskGetName = "pcTaskGetName";
static const char* CMockString_pcWriteBuffer = "pcWriteBuffer";
static const char* CMockString_pulNotificationValue = "pulNotificationValue";
static const char* CMockString_pulPreviousNotificationValue = "pulPreviousNotificationValue";
static const char* CMockString_pulTotalRunTime = "pulTotalRunTime";
static const char* CMockString_puxStackBuffer = "puxStackBuffer";
static const char* CMockString_pvParameter = "pvParameter";
static const char* CMockString_pvParameters = "pvParameters";
static const char* CMockString_pvTaskGetThreadLocalStoragePointer = "pvTaskGetThreadLocalStoragePointer";
static const char* CMockString_pvTaskIncrementMutexHeldCount = "pvTaskIncrementMutexHeldCount";
static const char* CMockString_pvValue = "pvValue";
static const char* CMockString_pxCreatedTask = "pxCreatedTask";
static const char* CMockString_pxEventList = "pxEventList";
static const char* CMockString_pxEventListItem = "pxEventListItem";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxHookFunction = "pxHookFunction";
static const char* CMockString_pxMutexHolder = "pxMutexHolder";
static const char* CMockString_pxPreviousWakeTime = "pxPreviousWakeTime";
static const char* CMockString_pxRegions = "pxRegions";
static const char* CMockString_pxTaskBuffer = "pxTaskBuffer";
static const char* CMockString_pxTaskCode = "pxTaskCode";
static const char* CMockString_pxTaskDefinition = "pxTaskDefinition";
static const char* CMockString_pxTaskStatus = "pxTaskStatus";
static const char* CMockString_pxTaskStatusArray = "pxTaskStatusArray";
static const char* CMockString_pxTicksToWait = "pxTicksToWait";
static const char* CMockString_pxTimeOut = "pxTimeOut";
static const char* CMockString_ulBitsToClearOnEntry = "ulBitsToClearOnEntry";
static const char* CMockString_ulBitsToClearOnExit = "ulBitsToClearOnExit";
static const char* CMockString_ulStackDepth = "ulStackDepth";
static const char* CMockString_ulTaskNotifyTake = "ulTaskNotifyTake";
static const char* CMockString_ulValue = "ulValue";
static const char* CMockString_usStackDepth = "usStackDepth";
static const char* CMockString_uxArraySize = "uxArraySize";
static const char* CMockString_uxHandle = "uxHandle";
static const char* CMockString_uxHighestPriorityWaitingTask = "uxHighestPriorityWaitingTask";
static const char* CMockString_uxNewPriority = "uxNewPriority";
static const char* CMockString_uxPriority = "uxPriority";
static const char* CMockString_uxTaskGetNumberOfTasks = "uxTaskGetNumberOfTasks";
static const char* CMockString_uxTaskGetStackHighWaterMark = "uxTaskGetStackHighWaterMark";
static const char* CMockString_uxTaskGetStackHighWaterMark2 = "uxTaskGetStackHighWaterMark2";
static const char* CMockString_uxTaskGetSystemState = "uxTaskGetSystemState";
static const char* CMockString_uxTaskGetTaskNumber = "uxTaskGetTaskNumber";
static const char* CMockString_uxTaskPriorityGet = "uxTaskPriorityGet";
static const char* CMockString_uxTaskPriorityGetFromISR = "uxTaskPriorityGetFromISR";
static const char* CMockString_uxTaskResetEventItemValue = "uxTaskResetEventItemValue";
static const char* CMockString_vTaskAllocateMPURegions = "vTaskAllocateMPURegions";
static const char* CMockString_vTaskDelay = "vTaskDelay";
static const char* CMockString_vTaskDelayUntil = "vTaskDelayUntil";
static const char* CMockString_vTaskDelete = "vTaskDelete";
static const char* CMockString_vTaskEndScheduler = "vTaskEndScheduler";
static const char* CMockString_vTaskGetInfo = "vTaskGetInfo";
static const char* CMockString_vTaskGetRunTimeStats = "vTaskGetRunTimeStats";
static const char* CMockString_vTaskInternalSetTimeOutState = "vTaskInternalSetTimeOutState";
static const char* CMockString_vTaskList = "vTaskList";
static const char* CMockString_vTaskMissedYield = "vTaskMissedYield";
static const char* CMockString_vTaskNotifyGiveFromISR = "vTaskNotifyGiveFromISR";
static const char* CMockString_vTaskPlaceOnEventList = "vTaskPlaceOnEventList";
static const char* CMockString_vTaskPlaceOnEventListRestricted = "vTaskPlaceOnEventListRestricted";
static const char* CMockString_vTaskPlaceOnUnorderedEventList = "vTaskPlaceOnUnorderedEventList";
static const char* CMockString_vTaskPriorityDisinheritAfterTimeout = "vTaskPriorityDisinheritAfterTimeout";
static const char* CMockString_vTaskPrioritySet = "vTaskPrioritySet";
static const char* CMockString_vTaskRemoveFromUnorderedEventList = "vTaskRemoveFromUnorderedEventList";
static const char* CMockString_vTaskResume = "vTaskResume";
static const char* CMockString_vTaskSetApplicationTaskTag = "vTaskSetApplicationTaskTag";
static const char* CMockString_vTaskSetTaskNumber = "vTaskSetTaskNumber";
static const char* CMockString_vTaskSetThreadLocalStoragePointer = "vTaskSetThreadLocalStoragePointer";
static const char* CMockString_vTaskSetTimeOutState = "vTaskSetTimeOutState";
static const char* CMockString_vTaskStartScheduler = "vTaskStartScheduler";
static const char* CMockString_vTaskStepTick = "vTaskStepTick";
static const char* CMockString_vTaskSuspend = "vTaskSuspend";
static const char* CMockString_vTaskSuspendAll = "vTaskSuspendAll";
static const char* CMockString_vTaskSwitchContext = "vTaskSwitchContext";
static const char* CMockString_xClearCountOnExit = "xClearCountOnExit";
static const char* CMockString_xGetFreeStackSpace = "xGetFreeStackSpace";
static const char* CMockString_xIndex = "xIndex";
static const char* CMockString_xItemValue = "xItemValue";
static const char* CMockString_xTask = "xTask";
static const char* CMockString_xTaskAbortDelay = "xTaskAbortDelay";
static const char* CMockString_xTaskCallApplicationTaskHook = "xTaskCallApplicationTaskHook";
static const char* CMockString_xTaskCheckForTimeOut = "xTaskCheckForTimeOut";
static const char* CMockString_xTaskCreate = "xTaskCreate";
static const char* CMockString_xTaskCreateRestricted = "xTaskCreateRestricted";
static const char* CMockString_xTaskCreateRestrictedStatic = "xTaskCreateRestrictedStatic";
static const char* CMockString_xTaskCreateStatic = "xTaskCreateStatic";
static const char* CMockString_xTaskGenericNotify = "xTaskGenericNotify";
static const char* CMockString_xTaskGenericNotifyFromISR = "xTaskGenericNotifyFromISR";
static const char* CMockString_xTaskGetApplicationTaskTag = "xTaskGetApplicationTaskTag";
static const char* CMockString_xTaskGetApplicationTaskTagFromISR = "xTaskGetApplicationTaskTagFromISR";
static const char* CMockString_xTaskGetCurrentTaskHandle = "xTaskGetCurrentTaskHandle";
static const char* CMockString_xTaskGetHandle = "xTaskGetHandle";
static const char* CMockString_xTaskGetIdleRunTimeCounter = "xTaskGetIdleRunTimeCounter";
static const char* CMockString_xTaskGetIdleTaskHandle = "xTaskGetIdleTaskHandle";
static const char* CMockString_xTaskGetSchedulerState = "xTaskGetSchedulerState";
static const char* CMockString_xTaskGetTickCount = "xTaskGetTickCount";
static const char* CMockString_xTaskGetTickCountFromISR = "xTaskGetTickCountFromISR";
static const char* CMockString_xTaskIncrementTick = "xTaskIncrementTick";
static const char* CMockString_xTaskNotifyStateClear = "xTaskNotifyStateClear";
static const char* CMockString_xTaskNotifyWait = "xTaskNotifyWait";
static const char* CMockString_xTaskPriorityDisinherit = "xTaskPriorityDisinherit";
static const char* CMockString_xTaskPriorityInherit = "xTaskPriorityInherit";
static const char* CMockString_xTaskRemoveFromEventList = "xTaskRemoveFromEventList";
static const char* CMockString_xTaskResumeAll = "xTaskResumeAll";
static const char* CMockString_xTaskResumeFromISR = "xTaskResumeFromISR";
static const char* CMockString_xTaskToDelete = "xTaskToDelete";
static const char* CMockString_xTaskToNotify = "xTaskToNotify";
static const char* CMockString_xTaskToQuery = "xTaskToQuery";
static const char* CMockString_xTaskToResume = "xTaskToResume";
static const char* CMockString_xTaskToSet = "xTaskToSet";
static const char* CMockString_xTaskToSuspend = "xTaskToSuspend";
static const char* CMockString_xTicksToDelay = "xTicksToDelay";
static const char* CMockString_xTicksToJump = "xTicksToJump";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTimeIncrement = "xTimeIncrement";
static const char* CMockString_xWaitIndefinitely = "xWaitIndefinitely";

typedef struct _CMOCK_xTaskCreate_CALL_INSTANCE {
    UNITY_LINE_TYPE LineNumber;
    BaseType_t ReturnVal;
    TaskFunction_t Expected_pxTaskCode;
    const char* Expected_pcName;
    configSTACK_DEPTH_TYPE Expected_usStackDepth;
    void* Expected_pvParameters;
    UBaseType_t Expected_uxPriority;
    TaskHandle_t* Expected_pxCreatedTask;
    int Expected_pvParameters_Depth;
    int Expected_pxCreatedTask_Depth;

} CMOCK_xTaskCreate_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;
  TaskFunction_t Expected_pxTaskCode;
  const char* Expected_pcName;
  uint32_t Expected_ulStackDepth;
  void* Expected_pvParameters;
  UBaseType_t Expected_uxPriority;
  StackType_t* Expected_puxStackBuffer;
  StaticTask_t* Expected_pxTaskBuffer;
  int Expected_pvParameters_Depth;
  int Expected_puxStackBuffer_Depth;
  int Expected_pxTaskBuffer_Depth;

} CMOCK_xTaskCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateRestricted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  const TaskParameters_t* Expected_pxTaskDefinition;
  TaskHandle_t* Expected_pxCreatedTask;
  int Expected_pxTaskDefinition_Depth;
  int Expected_pxCreatedTask_Depth;

} CMOCK_xTaskCreateRestricted_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  const TaskParameters_t* Expected_pxTaskDefinition;
  TaskHandle_t* Expected_pxCreatedTask;
  int Expected_pxTaskDefinition_Depth;
  int Expected_pxCreatedTask_Depth;

} CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE;

typedef struct _CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTask;
  const MemoryRegion_t* Expected_pxRegions;
  int Expected_pxRegions_Depth;

} CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTaskToDelete;

} CMOCK_vTaskDelete_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t Expected_xTicksToDelay;

} CMOCK_vTaskDelay_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelayUntil_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t* Expected_pxPreviousWakeTime;
  TickType_t Expected_xTimeIncrement;
  int Expected_pxPreviousWakeTime_Depth;

} CMOCK_vTaskDelayUntil_CALL_INSTANCE;

typedef struct _CMOCK_xTaskAbortDelay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_xTaskAbortDelay_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskPriorityGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_uxTaskPriorityGet_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE;

typedef struct _CMOCK_eTaskGetState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  eTaskState ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_eTaskGetState_CALL_INSTANCE;

typedef struct _CMOCK_vTaskGetInfo_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTask;
  TaskStatus_t* Expected_pxTaskStatus;
  BaseType_t Expected_xGetFreeStackSpace;
  eTaskState Expected_eState;
  int Expected_pxTaskStatus_Depth;

} CMOCK_vTaskGetInfo_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPrioritySet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxNewPriority;

} CMOCK_vTaskPrioritySet_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSuspend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTaskToSuspend;

} CMOCK_vTaskSuspend_CALL_INSTANCE;

typedef struct _CMOCK_vTaskResume_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTaskToResume;

} CMOCK_vTaskResume_CALL_INSTANCE;

typedef struct _CMOCK_xTaskResumeFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTaskToResume;

} CMOCK_xTaskResumeFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskStartScheduler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_vTaskStartScheduler_CALL_INSTANCE;

typedef struct _CMOCK_vTaskEndScheduler_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_vTaskEndScheduler_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSuspendAll_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_vTaskSuspendAll_CALL_INSTANCE;

typedef struct _CMOCK_xTaskResumeAll_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;

} CMOCK_xTaskResumeAll_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetTickCount_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;

} CMOCK_xTaskGetTickCount_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;

} CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;

} CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE;

typedef struct _CMOCK_pcTaskGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* ReturnVal;
  TaskHandle_t Expected_xTaskToQuery;

} CMOCK_pcTaskGetName_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;
  const char* Expected_pcNameToQuery;

} CMOCK_xTaskGetHandle_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  configSTACK_DEPTH_TYPE ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTask;
  TaskHookFunction_t Expected_pxHookFunction;

} CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHookFunction_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHookFunction_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTaskToSet;
  BaseType_t Expected_xIndex;
  void* Expected_pvValue;
  int Expected_pvValue_Depth;

} CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE;

typedef struct _CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  void* ReturnVal;
  TaskHandle_t Expected_xTaskToQuery;
  BaseType_t Expected_xIndex;

} CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;
  void* Expected_pvParameter;
  int Expected_pvParameter_Depth;

} CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;

} CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetSystemState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  TaskStatus_t* Expected_pxTaskStatusArray;
  UBaseType_t Expected_uxArraySize;
  uint32_t* Expected_pulTotalRunTime;
  int Expected_pxTaskStatusArray_Depth;
  int Expected_pulTotalRunTime_Depth;

} CMOCK_uxTaskGetSystemState_CALL_INSTANCE;

typedef struct _CMOCK_vTaskList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_pcWriteBuffer;

} CMOCK_vTaskList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char* Expected_pcWriteBuffer;

} CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;

} CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGenericNotify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTaskToNotify;
  uint32_t Expected_ulValue;
  eNotifyAction Expected_eAction;
  uint32_t* Expected_pulPreviousNotificationValue;
  int Expected_pulPreviousNotificationValue_Depth;

} CMOCK_xTaskGenericNotify_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTaskToNotify;
  uint32_t Expected_ulValue;
  eNotifyAction Expected_eAction;
  uint32_t* Expected_pulPreviousNotificationValue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pulPreviousNotificationValue_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;

} CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xTaskNotifyWait_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  uint32_t Expected_ulBitsToClearOnEntry;
  uint32_t Expected_ulBitsToClearOnExit;
  uint32_t* Expected_pulNotificationValue;
  TickType_t Expected_xTicksToWait;
  int Expected_pulNotificationValue_Depth;

} CMOCK_xTaskNotifyWait_CALL_INSTANCE;

typedef struct _CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTaskToNotify;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pxHigherPriorityTaskWoken_Depth;

} CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_ulTaskNotifyTake_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  BaseType_t Expected_xClearCountOnExit;
  TickType_t Expected_xTicksToWait;

} CMOCK_ulTaskNotifyTake_CALL_INSTANCE;

typedef struct _CMOCK_xTaskNotifyStateClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_xTaskNotifyStateClear_CALL_INSTANCE;

typedef struct _CMOCK_xTaskIncrementTick_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;

} CMOCK_xTaskIncrementTick_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  List_t* Expected_pxEventList;
  TickType_t Expected_xTicksToWait;
  int Expected_pxEventList_Depth;

} CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  List_t* Expected_pxEventList;
  TickType_t Expected_xItemValue;
  TickType_t Expected_xTicksToWait;
  int Expected_pxEventList_Depth;

} CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  List_t* Expected_pxEventList;
  TickType_t Expected_xTicksToWait;
  BaseType_t Expected_xWaitIndefinitely;
  int Expected_pxEventList_Depth;

} CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE;

typedef struct _CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  const List_t* Expected_pxEventList;
  int Expected_pxEventList_Depth;

} CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  ListItem_t* Expected_pxEventListItem;
  TickType_t Expected_xItemValue;
  int Expected_pxEventListItem_Depth;

} CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSwitchContext_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_vTaskSwitchContext_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;

} CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;

} CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetTimeOutState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimeOut_t* Expected_pxTimeOut;
  int Expected_pxTimeOut_Depth;

} CMOCK_vTaskSetTimeOutState_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TimeOut_t* Expected_pxTimeOut;
  TickType_t* Expected_pxTicksToWait;
  int Expected_pxTimeOut_Depth;
  int Expected_pxTicksToWait_Depth;

} CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE;

typedef struct _CMOCK_vTaskMissedYield_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_vTaskMissedYield_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetSchedulerState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;

} CMOCK_xTaskGetSchedulerState_CALL_INSTANCE;

typedef struct _CMOCK_xTaskPriorityInherit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_pxMutexHolder;

} CMOCK_xTaskPriorityInherit_CALL_INSTANCE;

typedef struct _CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TaskHandle_t Expected_pxMutexHolder;

} CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE;

typedef struct _CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_pxMutexHolder;
  UBaseType_t Expected_uxHighestPriorityWaitingTask;

} CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE;

typedef struct _CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  TaskHandle_t Expected_xTask;

} CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE;

typedef struct _CMOCK_vTaskSetTaskNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t Expected_xTask;
  UBaseType_t Expected_uxHandle;

} CMOCK_vTaskSetTaskNumber_CALL_INSTANCE;

typedef struct _CMOCK_vTaskStepTick_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t Expected_xTicksToJump;

} CMOCK_vTaskStepTick_CALL_INSTANCE;

typedef struct _CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  eSleepModeStatus ReturnVal;

} CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE;

typedef struct _CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;

} CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE;

typedef struct _CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimeOut_t* Expected_pxTimeOut;
  int Expected_pxTimeOut_Depth;

} CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE;

static struct MocktaskInstance
{
  CMOCK_MEM_INDEX_TYPE xTaskCreate_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateRestricted_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCreateRestrictedStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskAllocateMPURegions_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskDelete_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskDelay_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskDelayUntil_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskAbortDelay_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskPriorityGet_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskPriorityGetFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE eTaskGetState_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskGetInfo_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPrioritySet_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSuspend_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskResume_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskResumeFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskStartScheduler_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskEndScheduler_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSuspendAll_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskResumeAll_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetTickCount_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetTickCountFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetNumberOfTasks_CallInstance;
  CMOCK_MEM_INDEX_TYPE pcTaskGetName_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetStackHighWaterMark_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetStackHighWaterMark2_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetApplicationTaskTag_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetApplicationTaskTag_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetApplicationTaskTagFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetThreadLocalStoragePointer_CallInstance;
  CMOCK_MEM_INDEX_TYPE pvTaskGetThreadLocalStoragePointer_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCallApplicationTaskHook_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetIdleTaskHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetSystemState_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskGetRunTimeStats_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetIdleRunTimeCounter_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGenericNotify_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGenericNotifyFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskNotifyWait_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskNotifyGiveFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE ulTaskNotifyTake_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskNotifyStateClear_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskIncrementTick_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPlaceOnEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPlaceOnUnorderedEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPlaceOnEventListRestricted_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskRemoveFromEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskRemoveFromUnorderedEventList_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSwitchContext_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskResetEventItemValue_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetCurrentTaskHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetTimeOutState_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskCheckForTimeOut_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskMissedYield_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskGetSchedulerState_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskPriorityInherit_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTaskPriorityDisinherit_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskPriorityDisinheritAfterTimeout_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTaskGetTaskNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskSetTaskNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskStepTick_CallInstance;
  CMOCK_MEM_INDEX_TYPE eTaskConfirmSleepModeStatus_CallInstance;
  CMOCK_MEM_INDEX_TYPE pvTaskIncrementMutexHeldCount_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTaskInternalSetTimeOutState_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocktask_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xTaskCreate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateRestricted_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateRestricted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCreateRestrictedStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskAllocateMPURegions_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskAllocateMPURegions);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskDelete_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskDelay_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskDelay);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskDelayUntil_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskDelayUntil);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskAbortDelay_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskAbortDelay);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskPriorityGet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskPriorityGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskPriorityGetFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskPriorityGetFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.eTaskGetState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eTaskGetState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskGetInfo_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskGetInfo);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPrioritySet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPrioritySet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSuspend_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSuspend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskResume_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskResume);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskResumeFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskResumeFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskStartScheduler_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskStartScheduler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskEndScheduler_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskEndScheduler);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSuspendAll_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSuspendAll);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskResumeAll_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskResumeAll);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetTickCount_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetTickCount);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetTickCountFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetTickCountFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetNumberOfTasks_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetNumberOfTasks);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pcTaskGetName_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcTaskGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetStackHighWaterMark_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetStackHighWaterMark2_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark2);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetApplicationTaskTag_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetApplicationTaskTag);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetApplicationTaskTag_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTag);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetApplicationTaskTagFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTagFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetThreadLocalStoragePointer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetThreadLocalStoragePointer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pvTaskGetThreadLocalStoragePointer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTaskGetThreadLocalStoragePointer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCallApplicationTaskHook_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCallApplicationTaskHook);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetIdleTaskHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetIdleTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetSystemState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetSystemState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskGetRunTimeStats_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskGetRunTimeStats);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetIdleRunTimeCounter_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetIdleRunTimeCounter);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGenericNotify_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGenericNotify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGenericNotifyFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskNotifyWait_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskNotifyWait);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskNotifyGiveFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskNotifyGiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.ulTaskNotifyTake_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulTaskNotifyTake);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskNotifyStateClear_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskNotifyStateClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskIncrementTick_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskIncrementTick);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPlaceOnEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPlaceOnUnorderedEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPlaceOnUnorderedEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPlaceOnEventListRestricted_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventListRestricted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskRemoveFromEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskRemoveFromEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskRemoveFromUnorderedEventList_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskRemoveFromUnorderedEventList);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSwitchContext_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSwitchContext);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskResetEventItemValue_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskResetEventItemValue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetCurrentTaskHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetCurrentTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetTimeOutState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetTimeOutState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskCheckForTimeOut_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskCheckForTimeOut);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskMissedYield_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskMissedYield);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskGetSchedulerState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskGetSchedulerState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskPriorityInherit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskPriorityInherit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTaskPriorityDisinherit_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTaskPriorityDisinherit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskPriorityDisinheritAfterTimeout);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTaskGetTaskNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTaskGetTaskNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskSetTaskNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskSetTaskNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskStepTick_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskStepTick);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.eTaskConfirmSleepModeStatus_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eTaskConfirmSleepModeStatus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pvTaskIncrementMutexHeldCount_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTaskIncrementMutexHeldCount);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTaskInternalSetTimeOutState_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTaskInternalSetTimeOutState);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mocktask_Init(void)
{
  Mocktask_Destroy();
}

void Mocktask_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

BaseType_t xTaskCreate(TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreate);
  cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreate_CallInstance);
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pxTaskCode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pcName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_usStackDepth);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_usStackDepth), (void*)(&usStackDepth), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, cmock_call_instance->Expected_pvParameters_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_uxPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pxCreatedTask);
    if (cmock_call_instance->Expected_pxCreatedTask == NULL)
      { UNITY_TEST_ASSERT_NULL(pxCreatedTask, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_call_instance->Expected_pxCreatedTask_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreate(CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, int pxCreatedTask_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pcName = pcName;
  memcpy((void*)(&cmock_call_instance->Expected_usStackDepth), (void*)(&usStackDepth),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(usStackDepth) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->Expected_pvParameters_Depth = pvParameters_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->Expected_pxCreatedTask_Depth = pxCreatedTask_Depth;
}

void xTaskCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreate(cmock_call_instance, pxTaskCode, pcName, usStackDepth, pvParameters, 1, uxPriority, pxCreatedTask, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, int pxCreatedTask_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreate(cmock_call_instance, pxTaskCode, pcName, usStackDepth, pvParameters, pvParameters_Depth, uxPriority, pxCreatedTask, pxCreatedTask_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode, const char* const pcName, const uint32_t ulStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateStatic);
  cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateStatic_CallInstance);
  Mock.xTaskCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pxTaskCode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pcName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_ulStackDepth);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulStackDepth, ulStackDepth, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, cmock_call_instance->Expected_pvParameters_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_uxPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_puxStackBuffer);
    if (cmock_call_instance->Expected_puxStackBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(puxStackBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_puxStackBuffer), (void*)(puxStackBuffer), sizeof(StackType_t), cmock_call_instance->Expected_puxStackBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateStatic,CMockString_pxTaskBuffer);
    if (cmock_call_instance->Expected_pxTaskBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTaskBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTaskBuffer), (void*)(pxTaskBuffer), sizeof(StaticTask_t), cmock_call_instance->Expected_pxTaskBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateStatic(CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const uint32_t ulStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, int puxStackBuffer_Depth, StaticTask_t* const pxTaskBuffer, int pxTaskBuffer_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pcName = pcName;
  cmock_call_instance->Expected_ulStackDepth = ulStackDepth;
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->Expected_pvParameters_Depth = pvParameters_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_puxStackBuffer = puxStackBuffer;
  cmock_call_instance->Expected_puxStackBuffer_Depth = puxStackBuffer_Depth;
  cmock_call_instance->Expected_pxTaskBuffer = pxTaskBuffer;
  cmock_call_instance->Expected_pxTaskBuffer_Depth = pxTaskBuffer_Depth;
}

void xTaskCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const uint32_t ulStackDepth, void* const pvParameters, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, StaticTask_t* const pxTaskBuffer, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreateStatic(cmock_call_instance, pxTaskCode, pcName, ulStackDepth, pvParameters, 1, uxPriority, puxStackBuffer, 1, pxTaskBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskCreateStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const uint32_t ulStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, StackType_t* const puxStackBuffer, int puxStackBuffer_Depth, StaticTask_t* const pxTaskBuffer, int pxTaskBuffer_Depth, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreateStatic(cmock_call_instance, pxTaskCode, pcName, ulStackDepth, pvParameters, pvParameters_Depth, uxPriority, puxStackBuffer, puxStackBuffer_Depth, pxTaskBuffer, pxTaskBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

BaseType_t xTaskCreateRestricted(const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateRestricted);
  cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateRestricted_CallInstance);
  Mock.xTaskCreateRestricted_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateRestricted_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestricted,CMockString_pxTaskDefinition);
    if (cmock_call_instance->Expected_pxTaskDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTaskDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTaskDefinition), (void*)(pxTaskDefinition), sizeof(const TaskParameters_t), cmock_call_instance->Expected_pxTaskDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestricted,CMockString_pxCreatedTask);
    if (cmock_call_instance->Expected_pxCreatedTask == NULL)
      { UNITY_TEST_ASSERT_NULL(pxCreatedTask, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_call_instance->Expected_pxCreatedTask_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateRestricted(CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, int pxTaskDefinition_Depth, TaskHandle_t* pxCreatedTask, int pxCreatedTask_Depth)
{
  cmock_call_instance->Expected_pxTaskDefinition = pxTaskDefinition;
  cmock_call_instance->Expected_pxTaskDefinition_Depth = pxTaskDefinition_Depth;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->Expected_pxCreatedTask_Depth = pxCreatedTask_Depth;
}

void xTaskCreateRestricted_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestricted_CALL_INSTANCE));
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestricted_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreateRestricted(cmock_call_instance, pxTaskDefinition, 1, pxCreatedTask, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateRestricted_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, int pxTaskDefinition_Depth, TaskHandle_t* pxCreatedTask, int pxCreatedTask_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestricted_CALL_INSTANCE));
  CMOCK_xTaskCreateRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestricted_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreateRestricted(cmock_call_instance, pxTaskDefinition, pxTaskDefinition_Depth, pxCreatedTask, pxCreatedTask_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

BaseType_t xTaskCreateRestrictedStatic(const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreateRestrictedStatic);
  cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreateRestrictedStatic_CallInstance);
  Mock.xTaskCreateRestrictedStatic_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreateRestrictedStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStatic,CMockString_pxTaskDefinition);
    if (cmock_call_instance->Expected_pxTaskDefinition == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTaskDefinition, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTaskDefinition), (void*)(pxTaskDefinition), sizeof(const TaskParameters_t), cmock_call_instance->Expected_pxTaskDefinition_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreateRestrictedStatic,CMockString_pxCreatedTask);
    if (cmock_call_instance->Expected_pxCreatedTask == NULL)
      { UNITY_TEST_ASSERT_NULL(pxCreatedTask, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_call_instance->Expected_pxCreatedTask_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreateRestrictedStatic(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance, const TaskParameters_t* const pxTaskDefinition, int pxTaskDefinition_Depth, TaskHandle_t* pxCreatedTask, int pxCreatedTask_Depth)
{
  cmock_call_instance->Expected_pxTaskDefinition = pxTaskDefinition;
  cmock_call_instance->Expected_pxTaskDefinition_Depth = pxTaskDefinition_Depth;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->Expected_pxCreatedTask_Depth = pxCreatedTask_Depth;
}

void xTaskCreateRestrictedStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, TaskHandle_t* pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreateRestrictedStatic(cmock_call_instance, pxTaskDefinition, 1, pxCreatedTask, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreateRestrictedStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const TaskParameters_t* const pxTaskDefinition, int pxTaskDefinition_Depth, TaskHandle_t* pxCreatedTask, int pxCreatedTask_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE));
  CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreateRestrictedStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreateRestrictedStatic_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreateRestrictedStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCreateRestrictedStatic(cmock_call_instance, pxTaskDefinition, pxTaskDefinition_Depth, pxCreatedTask, pxCreatedTask_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTaskAllocateMPURegions(TaskHandle_t xTask, const MemoryRegion_t* const pxRegions)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskAllocateMPURegions);
  cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskAllocateMPURegions_CallInstance);
  Mock.vTaskAllocateMPURegions_CallInstance = CMock_Guts_MemNext(Mock.vTaskAllocateMPURegions_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskAllocateMPURegions,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskAllocateMPURegions,CMockString_pxRegions);
    if (cmock_call_instance->Expected_pxRegions == NULL)
      { UNITY_TEST_ASSERT_NULL(pxRegions, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxRegions), (void*)(pxRegions), sizeof(const MemoryRegion_t), cmock_call_instance->Expected_pxRegions_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskAllocateMPURegions(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, const MemoryRegion_t* const pxRegions, int pxRegions_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxRegions = pxRegions;
  cmock_call_instance->Expected_pxRegions_Depth = pxRegions_Depth;
}

void vTaskAllocateMPURegions_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, const MemoryRegion_t* const pxRegions)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE));
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskAllocateMPURegions_CallInstance = CMock_Guts_MemChain(Mock.vTaskAllocateMPURegions_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskAllocateMPURegions(cmock_call_instance, xTask, pxRegions, 1);
}

void vTaskAllocateMPURegions_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, const MemoryRegion_t* const pxRegions, int pxRegions_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE));
  CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskAllocateMPURegions_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskAllocateMPURegions_CallInstance = CMock_Guts_MemChain(Mock.vTaskAllocateMPURegions_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskAllocateMPURegions(cmock_call_instance, xTask, pxRegions, pxRegions_Depth);
}

void vTaskDelete(TaskHandle_t xTaskToDelete)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelete);
  cmock_call_instance = (CMOCK_vTaskDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelete_CallInstance);
  Mock.vTaskDelete_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelete_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelete,CMockString_xTaskToDelete);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToDelete), (void*)(&xTaskToDelete), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelete(CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToDelete)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToDelete), (void*)(&xTaskToDelete),
         sizeof(TaskHandle_t[sizeof(xTaskToDelete) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void vTaskDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToDelete)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelete_CALL_INSTANCE));
  CMOCK_vTaskDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelete_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskDelete(cmock_call_instance, xTaskToDelete);
}

void vTaskDelay(const TickType_t xTicksToDelay)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelay);
  cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelay_CallInstance);
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelay_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelay,CMockString_xTicksToDelay);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToDelay), (void*)(&xTicksToDelay), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelay(CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance, const TickType_t xTicksToDelay)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToDelay), (void*)(&xTicksToDelay),
         sizeof(TickType_t[sizeof(xTicksToDelay) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void vTaskDelay_CMockExpect(UNITY_LINE_TYPE cmock_line, const TickType_t xTicksToDelay)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskDelay(cmock_call_instance, xTicksToDelay);
}

void vTaskDelayUntil(TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelayUntil);
  cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelayUntil_CallInstance);
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelayUntil_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelayUntil,CMockString_pxPreviousWakeTime);
    if (cmock_call_instance->Expected_pxPreviousWakeTime == NULL)
      { UNITY_TEST_ASSERT_NULL(pxPreviousWakeTime, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxPreviousWakeTime), (void*)(pxPreviousWakeTime), sizeof(TickType_t), cmock_call_instance->Expected_pxPreviousWakeTime_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelayUntil,CMockString_xTimeIncrement);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimeIncrement), (void*)(&xTimeIncrement), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelayUntil(CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance, TickType_t* const pxPreviousWakeTime, int pxPreviousWakeTime_Depth, const TickType_t xTimeIncrement)
{
  cmock_call_instance->Expected_pxPreviousWakeTime = pxPreviousWakeTime;
  cmock_call_instance->Expected_pxPreviousWakeTime_Depth = pxPreviousWakeTime_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xTimeIncrement), (void*)(&xTimeIncrement),
         sizeof(TickType_t[sizeof(xTimeIncrement) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void vTaskDelayUntil_CMockExpect(UNITY_LINE_TYPE cmock_line, TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelayUntil_CALL_INSTANCE));
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelayUntil_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskDelayUntil(cmock_call_instance, pxPreviousWakeTime, 1, xTimeIncrement);
}

void vTaskDelayUntil_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TickType_t* const pxPreviousWakeTime, int pxPreviousWakeTime_Depth, const TickType_t xTimeIncrement)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelayUntil_CALL_INSTANCE));
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelayUntil_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskDelayUntil(cmock_call_instance, pxPreviousWakeTime, pxPreviousWakeTime_Depth, xTimeIncrement);
}

BaseType_t xTaskAbortDelay(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskAbortDelay);
  cmock_call_instance = (CMOCK_xTaskAbortDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskAbortDelay_CallInstance);
  Mock.xTaskAbortDelay_CallInstance = CMock_Guts_MemNext(Mock.xTaskAbortDelay_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskAbortDelay,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskAbortDelay(CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskAbortDelay_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskAbortDelay_CALL_INSTANCE));
  CMOCK_xTaskAbortDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskAbortDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskAbortDelay_CallInstance = CMock_Guts_MemChain(Mock.xTaskAbortDelay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskAbortDelay(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxTaskPriorityGet(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskPriorityGet);
  cmock_call_instance = (CMOCK_uxTaskPriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskPriorityGet_CallInstance);
  Mock.uxTaskPriorityGet_CallInstance = CMock_Guts_MemNext(Mock.uxTaskPriorityGet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTaskPriorityGet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskPriorityGet(CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void uxTaskPriorityGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskPriorityGet_CALL_INSTANCE));
  CMOCK_uxTaskPriorityGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskPriorityGet_CallInstance = CMock_Guts_MemChain(Mock.uxTaskPriorityGet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskPriorityGet(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxTaskPriorityGetFromISR(const TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskPriorityGetFromISR);
  cmock_call_instance = (CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskPriorityGetFromISR_CallInstance);
  Mock.uxTaskPriorityGetFromISR_CallInstance = CMock_Guts_MemNext(Mock.uxTaskPriorityGetFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTaskPriorityGetFromISR,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskPriorityGetFromISR(CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void uxTaskPriorityGetFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE));
  CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskPriorityGetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskPriorityGetFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxTaskPriorityGetFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskPriorityGetFromISR(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

eTaskState eTaskGetState(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eTaskGetState);
  cmock_call_instance = (CMOCK_eTaskGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eTaskGetState_CallInstance);
  Mock.eTaskGetState_CallInstance = CMock_Guts_MemNext(Mock.eTaskGetState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_eTaskGetState,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_eTaskGetState(CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void eTaskGetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, eTaskState cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eTaskGetState_CALL_INSTANCE));
  CMOCK_eTaskGetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_eTaskGetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eTaskGetState_CallInstance = CMock_Guts_MemChain(Mock.eTaskGetState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_eTaskGetState(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eTaskState[sizeof(cmock_to_return) == sizeof(eTaskState) ? 1 : -1])); /* add eTaskState to :treat_as_array if this causes an error */
}

void vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskGetInfo);
  cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskGetInfo_CallInstance);
  Mock.vTaskGetInfo_CallInstance = CMock_Guts_MemNext(Mock.vTaskGetInfo_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_pxTaskStatus);
    if (cmock_call_instance->Expected_pxTaskStatus == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTaskStatus, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTaskStatus), (void*)(pxTaskStatus), sizeof(TaskStatus_t), cmock_call_instance->Expected_pxTaskStatus_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_xGetFreeStackSpace);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xGetFreeStackSpace), (void*)(&xGetFreeStackSpace), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetInfo,CMockString_eState);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eState), (void*)(&eState), sizeof(eTaskState), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskGetInfo(CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, int pxTaskStatus_Depth, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxTaskStatus = pxTaskStatus;
  cmock_call_instance->Expected_pxTaskStatus_Depth = pxTaskStatus_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xGetFreeStackSpace), (void*)(&xGetFreeStackSpace),
         sizeof(BaseType_t[sizeof(xGetFreeStackSpace) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_eState), (void*)(&eState),
         sizeof(eTaskState[sizeof(eState) == sizeof(eTaskState) ? 1 : -1])); /* add eTaskState to :treat_as_array if this causes an error */
}

void vTaskGetInfo_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetInfo_CALL_INSTANCE));
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetInfo_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetInfo_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskGetInfo(cmock_call_instance, xTask, pxTaskStatus, 1, xGetFreeStackSpace, eState);
}

void vTaskGetInfo_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskStatus_t* pxTaskStatus, int pxTaskStatus_Depth, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetInfo_CALL_INSTANCE));
  CMOCK_vTaskGetInfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetInfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetInfo_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetInfo_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskGetInfo(cmock_call_instance, xTask, pxTaskStatus, pxTaskStatus_Depth, xGetFreeStackSpace, eState);
}

void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPrioritySet);
  cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPrioritySet_CallInstance);
  Mock.vTaskPrioritySet_CallInstance = CMock_Guts_MemNext(Mock.vTaskPrioritySet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskPrioritySet,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPrioritySet,CMockString_uxNewPriority);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxNewPriority), (void*)(&uxNewPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPrioritySet(CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxNewPriority), (void*)(&uxNewPriority),
         sizeof(UBaseType_t[sizeof(uxNewPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTaskPrioritySet_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t uxNewPriority)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPrioritySet_CALL_INSTANCE));
  CMOCK_vTaskPrioritySet_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPrioritySet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPrioritySet_CallInstance = CMock_Guts_MemChain(Mock.vTaskPrioritySet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPrioritySet(cmock_call_instance, xTask, uxNewPriority);
}

void vTaskSuspend(TaskHandle_t xTaskToSuspend)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSuspend);
  cmock_call_instance = (CMOCK_vTaskSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSuspend_CallInstance);
  Mock.vTaskSuspend_CallInstance = CMock_Guts_MemNext(Mock.vTaskSuspend_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskSuspend,CMockString_xTaskToSuspend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToSuspend), (void*)(&xTaskToSuspend), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSuspend(CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToSuspend)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToSuspend), (void*)(&xTaskToSuspend),
         sizeof(TaskHandle_t[sizeof(xTaskToSuspend) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void vTaskSuspend_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToSuspend)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSuspend_CALL_INSTANCE));
  CMOCK_vTaskSuspend_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSuspend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSuspend_CallInstance = CMock_Guts_MemChain(Mock.vTaskSuspend_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSuspend(cmock_call_instance, xTaskToSuspend);
}

void vTaskResume(TaskHandle_t xTaskToResume)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskResume);
  cmock_call_instance = (CMOCK_vTaskResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskResume_CallInstance);
  Mock.vTaskResume_CallInstance = CMock_Guts_MemNext(Mock.vTaskResume_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskResume,CMockString_xTaskToResume);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskResume(CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToResume)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume),
         sizeof(TaskHandle_t[sizeof(xTaskToResume) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void vTaskResume_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToResume)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskResume_CALL_INSTANCE));
  CMOCK_vTaskResume_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskResume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskResume_CallInstance = CMock_Guts_MemChain(Mock.vTaskResume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskResume(cmock_call_instance, xTaskToResume);
}

BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskResumeFromISR);
  cmock_call_instance = (CMOCK_xTaskResumeFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskResumeFromISR_CallInstance);
  Mock.xTaskResumeFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskResumeFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskResumeFromISR,CMockString_xTaskToResume);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskResumeFromISR(CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToResume)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToResume), (void*)(&xTaskToResume),
         sizeof(TaskHandle_t[sizeof(xTaskToResume) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskResumeFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToResume, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskResumeFromISR_CALL_INSTANCE));
  CMOCK_xTaskResumeFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskResumeFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskResumeFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskResumeFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskResumeFromISR(cmock_call_instance, xTaskToResume);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vTaskStartScheduler(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskStartScheduler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskStartScheduler);
  cmock_call_instance = (CMOCK_vTaskStartScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskStartScheduler_CallInstance);
  Mock.vTaskStartScheduler_CallInstance = CMock_Guts_MemNext(Mock.vTaskStartScheduler_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskStartScheduler_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskStartScheduler_CALL_INSTANCE));
  CMOCK_vTaskStartScheduler_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskStartScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskStartScheduler_CallInstance = CMock_Guts_MemChain(Mock.vTaskStartScheduler_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void vTaskEndScheduler(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskEndScheduler_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskEndScheduler);
  cmock_call_instance = (CMOCK_vTaskEndScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskEndScheduler_CallInstance);
  Mock.vTaskEndScheduler_CallInstance = CMock_Guts_MemNext(Mock.vTaskEndScheduler_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskEndScheduler_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskEndScheduler_CALL_INSTANCE));
  CMOCK_vTaskEndScheduler_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskEndScheduler_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskEndScheduler_CallInstance = CMock_Guts_MemChain(Mock.vTaskEndScheduler_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void vTaskSuspendAll(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSuspendAll_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSuspendAll);
  cmock_call_instance = (CMOCK_vTaskSuspendAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSuspendAll_CallInstance);
  Mock.vTaskSuspendAll_CallInstance = CMock_Guts_MemNext(Mock.vTaskSuspendAll_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskSuspendAll_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSuspendAll_CALL_INSTANCE));
  CMOCK_vTaskSuspendAll_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSuspendAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSuspendAll_CallInstance = CMock_Guts_MemChain(Mock.vTaskSuspendAll_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

BaseType_t xTaskResumeAll(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskResumeAll_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskResumeAll);
  cmock_call_instance = (CMOCK_xTaskResumeAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskResumeAll_CallInstance);
  Mock.xTaskResumeAll_CallInstance = CMock_Guts_MemNext(Mock.xTaskResumeAll_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskResumeAll_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskResumeAll_CALL_INSTANCE));
  CMOCK_xTaskResumeAll_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskResumeAll_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskResumeAll_CallInstance = CMock_Guts_MemChain(Mock.xTaskResumeAll_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

TickType_t xTaskGetTickCount(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCount);
  cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetTickCount_CallInstance);
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetTickCount_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetTickCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCount_CALL_INSTANCE));
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCount_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

TickType_t xTaskGetTickCountFromISR(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCountFromISR);
  cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetTickCountFromISR_CallInstance);
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetTickCountFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetTickCountFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCountFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

UBaseType_t uxTaskGetNumberOfTasks(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetNumberOfTasks);
  cmock_call_instance = (CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetNumberOfTasks_CallInstance);
  Mock.uxTaskGetNumberOfTasks_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetNumberOfTasks_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void uxTaskGetNumberOfTasks_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE));
  CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetNumberOfTasks_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetNumberOfTasks_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetNumberOfTasks_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

char* pcTaskGetName(TaskHandle_t xTaskToQuery)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcTaskGetName);
  cmock_call_instance = (CMOCK_pcTaskGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcTaskGetName_CallInstance);
  Mock.pcTaskGetName_CallInstance = CMock_Guts_MemNext(Mock.pcTaskGetName_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_pcTaskGetName,CMockString_xTaskToQuery);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcTaskGetName(CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToQuery)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery),
         sizeof(TaskHandle_t[sizeof(xTaskToQuery) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void pcTaskGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToQuery, char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTaskGetName_CALL_INSTANCE));
  CMOCK_pcTaskGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTaskGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTaskGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTaskGetName_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pcTaskGetName(cmock_call_instance, xTaskToQuery);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

TaskHandle_t xTaskGetHandle(const char* pcNameToQuery)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetHandle);
  cmock_call_instance = (CMOCK_xTaskGetHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetHandle_CallInstance);
  Mock.xTaskGetHandle_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetHandle,CMockString_pcNameToQuery);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcNameToQuery, pcNameToQuery, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetHandle(CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance, const char* pcNameToQuery)
{
  cmock_call_instance->Expected_pcNameToQuery = pcNameToQuery;
}

void xTaskGetHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* pcNameToQuery, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetHandle_CALL_INSTANCE));
  CMOCK_xTaskGetHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGetHandle(cmock_call_instance, pcNameToQuery);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark);
  cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetStackHighWaterMark_CallInstance);
  Mock.uxTaskGetStackHighWaterMark_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetStackHighWaterMark_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetStackHighWaterMark,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetStackHighWaterMark(CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void uxTaskGetStackHighWaterMark_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE));
  CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetStackHighWaterMark_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetStackHighWaterMark_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskGetStackHighWaterMark(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetStackHighWaterMark2);
  cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetStackHighWaterMark2_CallInstance);
  Mock.uxTaskGetStackHighWaterMark2_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetStackHighWaterMark2_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetStackHighWaterMark2,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetStackHighWaterMark2(CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void uxTaskGetStackHighWaterMark2_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, configSTACK_DEPTH_TYPE cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE));
  CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetStackHighWaterMark2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetStackHighWaterMark2_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetStackHighWaterMark2_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskGetStackHighWaterMark2(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(cmock_to_return) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
}

void vTaskSetApplicationTaskTag(TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetApplicationTaskTag);
  cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetApplicationTaskTag_CallInstance);
  Mock.vTaskSetApplicationTaskTag_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetApplicationTaskTag_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetApplicationTaskTag,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetApplicationTaskTag,CMockString_pxHookFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxHookFunction), (void*)(&pxHookFunction), sizeof(TaskHookFunction_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetApplicationTaskTag(CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_pxHookFunction), (void*)(&pxHookFunction),
         sizeof(TaskHookFunction_t[sizeof(pxHookFunction) == sizeof(TaskHookFunction_t) ? 1 : -1])); /* add TaskHookFunction_t to :treat_as_array if this causes an error */
}

void vTaskSetApplicationTaskTag_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskHookFunction_t pxHookFunction)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE));
  CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetApplicationTaskTag_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetApplicationTaskTag_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSetApplicationTaskTag(cmock_call_instance, xTask, pxHookFunction);
}

TaskHookFunction_t xTaskGetApplicationTaskTag(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTag);
  cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetApplicationTaskTag_CallInstance);
  Mock.xTaskGetApplicationTaskTag_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetApplicationTaskTag_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetApplicationTaskTag,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetApplicationTaskTag(CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskGetApplicationTaskTag_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskHookFunction_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE));
  CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTag_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetApplicationTaskTag_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetApplicationTaskTag_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGetApplicationTaskTag(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHookFunction_t[sizeof(cmock_to_return) == sizeof(TaskHookFunction_t) ? 1 : -1])); /* add TaskHookFunction_t to :treat_as_array if this causes an error */
}

TaskHookFunction_t xTaskGetApplicationTaskTagFromISR(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetApplicationTaskTagFromISR);
  cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance);
  Mock.xTaskGetApplicationTaskTagFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskGetApplicationTaskTagFromISR,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGetApplicationTaskTagFromISR(CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskGetApplicationTaskTagFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, TaskHookFunction_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetApplicationTaskTagFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetApplicationTaskTagFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetApplicationTaskTagFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGetApplicationTaskTagFromISR(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHookFunction_t[sizeof(cmock_to_return) == sizeof(TaskHookFunction_t) ? 1 : -1])); /* add TaskHookFunction_t to :treat_as_array if this causes an error */
}

void vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetThreadLocalStoragePointer);
  cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetThreadLocalStoragePointer_CallInstance);
  Mock.vTaskSetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetThreadLocalStoragePointer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetThreadLocalStoragePointer,CMockString_xTaskToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToSet), (void*)(&xTaskToSet), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetThreadLocalStoragePointer,CMockString_xIndex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetThreadLocalStoragePointer,CMockString_pvValue);
    if (cmock_call_instance->Expected_pvValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvValue, pvValue, cmock_call_instance->Expected_pvValue_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetThreadLocalStoragePointer(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue, int pvValue_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToSet), (void*)(&xTaskToSet),
         sizeof(TaskHandle_t[sizeof(xTaskToSet) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex),
         sizeof(BaseType_t[sizeof(xIndex) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvValue = pvValue;
  cmock_call_instance->Expected_pvValue_Depth = pvValue_Depth;
}

void vTaskSetThreadLocalStoragePointer_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSetThreadLocalStoragePointer(cmock_call_instance, xTaskToSet, xIndex, pvValue, 1);
}

void vTaskSetThreadLocalStoragePointer_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToSet, BaseType_t xIndex, void* pvValue, int pvValue_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSetThreadLocalStoragePointer(cmock_call_instance, xTaskToSet, xIndex, pvValue, pvValue_Depth);
}

void* pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTaskGetThreadLocalStoragePointer);
  cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance);
  Mock.pvTaskGetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemNext(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_pvTaskGetThreadLocalStoragePointer,CMockString_xTaskToQuery);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_pvTaskGetThreadLocalStoragePointer,CMockString_xIndex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pvTaskGetThreadLocalStoragePointer(CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToQuery), (void*)(&xTaskToQuery),
         sizeof(TaskHandle_t[sizeof(xTaskToQuery) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xIndex), (void*)(&xIndex),
         sizeof(BaseType_t[sizeof(xIndex) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void pvTaskGetThreadLocalStoragePointer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToQuery, BaseType_t xIndex, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE));
  CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskGetThreadLocalStoragePointer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTaskGetThreadLocalStoragePointer_CallInstance = CMock_Guts_MemChain(Mock.pvTaskGetThreadLocalStoragePointer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pvTaskGetThreadLocalStoragePointer(cmock_call_instance, xTaskToQuery, xIndex);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

BaseType_t xTaskCallApplicationTaskHook(TaskHandle_t xTask, void* pvParameter)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCallApplicationTaskHook);
  cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCallApplicationTaskHook_CallInstance);
  Mock.xTaskCallApplicationTaskHook_CallInstance = CMock_Guts_MemNext(Mock.xTaskCallApplicationTaskHook_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskCallApplicationTaskHook,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCallApplicationTaskHook,CMockString_pvParameter);
    if (cmock_call_instance->Expected_pvParameter == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter, pvParameter, cmock_call_instance->Expected_pvParameter_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCallApplicationTaskHook(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, void* pvParameter, int pvParameter_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvParameter = pvParameter;
  cmock_call_instance->Expected_pvParameter_Depth = pvParameter_Depth;
}

void xTaskCallApplicationTaskHook_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, void* pvParameter, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE));
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCallApplicationTaskHook_CallInstance = CMock_Guts_MemChain(Mock.xTaskCallApplicationTaskHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCallApplicationTaskHook(cmock_call_instance, xTask, pvParameter, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCallApplicationTaskHook_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, void* pvParameter, int pvParameter_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE));
  CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCallApplicationTaskHook_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCallApplicationTaskHook_CallInstance = CMock_Guts_MemChain(Mock.xTaskCallApplicationTaskHook_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCallApplicationTaskHook(cmock_call_instance, xTask, pvParameter, pvParameter_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

TaskHandle_t xTaskGetIdleTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetIdleTaskHandle);
  cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetIdleTaskHandle_CallInstance);
  Mock.xTaskGetIdleTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetIdleTaskHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetIdleTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE));
  CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetIdleTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetIdleTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetIdleTaskHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

UBaseType_t uxTaskGetSystemState(TaskStatus_t* const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t* const pulTotalRunTime)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetSystemState);
  cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetSystemState_CallInstance);
  Mock.uxTaskGetSystemState_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetSystemState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetSystemState,CMockString_pxTaskStatusArray);
    if (cmock_call_instance->Expected_pxTaskStatusArray == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTaskStatusArray, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTaskStatusArray), (void*)(pxTaskStatusArray), sizeof(TaskStatus_t), cmock_call_instance->Expected_pxTaskStatusArray_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetSystemState,CMockString_uxArraySize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxArraySize), (void*)(&uxArraySize), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetSystemState,CMockString_pulTotalRunTime);
    if (cmock_call_instance->Expected_pulTotalRunTime == NULL)
      { UNITY_TEST_ASSERT_NULL(pulTotalRunTime, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulTotalRunTime, pulTotalRunTime, cmock_call_instance->Expected_pulTotalRunTime_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetSystemState(CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance, TaskStatus_t* const pxTaskStatusArray, int pxTaskStatusArray_Depth, const UBaseType_t uxArraySize, uint32_t* const pulTotalRunTime, int pulTotalRunTime_Depth)
{
  cmock_call_instance->Expected_pxTaskStatusArray = pxTaskStatusArray;
  cmock_call_instance->Expected_pxTaskStatusArray_Depth = pxTaskStatusArray_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_uxArraySize), (void*)(&uxArraySize),
         sizeof(UBaseType_t[sizeof(uxArraySize) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pulTotalRunTime = pulTotalRunTime;
  cmock_call_instance->Expected_pulTotalRunTime_Depth = pulTotalRunTime_Depth;
}

void uxTaskGetSystemState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskStatus_t* const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t* const pulTotalRunTime, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetSystemState_CALL_INSTANCE));
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetSystemState_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetSystemState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskGetSystemState(cmock_call_instance, pxTaskStatusArray, 1, uxArraySize, pulTotalRunTime, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTaskGetSystemState_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskStatus_t* const pxTaskStatusArray, int pxTaskStatusArray_Depth, const UBaseType_t uxArraySize, uint32_t* const pulTotalRunTime, int pulTotalRunTime_Depth, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetSystemState_CALL_INSTANCE));
  CMOCK_uxTaskGetSystemState_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetSystemState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetSystemState_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetSystemState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskGetSystemState(cmock_call_instance, pxTaskStatusArray, pxTaskStatusArray_Depth, uxArraySize, pulTotalRunTime, pulTotalRunTime_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTaskList(char* pcWriteBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskList);
  cmock_call_instance = (CMOCK_vTaskList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskList_CallInstance);
  Mock.vTaskList_CallInstance = CMock_Guts_MemNext(Mock.vTaskList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskList,CMockString_pcWriteBuffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcWriteBuffer, pcWriteBuffer, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskList(CMOCK_vTaskList_CALL_INSTANCE* cmock_call_instance, char* pcWriteBuffer)
{
  cmock_call_instance->Expected_pcWriteBuffer = pcWriteBuffer;
}

void vTaskList_CMockExpect(UNITY_LINE_TYPE cmock_line, char* pcWriteBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskList_CALL_INSTANCE));
  CMOCK_vTaskList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskList_CallInstance = CMock_Guts_MemChain(Mock.vTaskList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskList(cmock_call_instance, pcWriteBuffer);
}

void vTaskGetRunTimeStats(char* pcWriteBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskGetRunTimeStats);
  cmock_call_instance = (CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskGetRunTimeStats_CallInstance);
  Mock.vTaskGetRunTimeStats_CallInstance = CMock_Guts_MemNext(Mock.vTaskGetRunTimeStats_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskGetRunTimeStats,CMockString_pcWriteBuffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcWriteBuffer, pcWriteBuffer, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskGetRunTimeStats(CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE* cmock_call_instance, char* pcWriteBuffer)
{
  cmock_call_instance->Expected_pcWriteBuffer = pcWriteBuffer;
}

void vTaskGetRunTimeStats_CMockExpect(UNITY_LINE_TYPE cmock_line, char* pcWriteBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE));
  CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskGetRunTimeStats_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskGetRunTimeStats_CallInstance = CMock_Guts_MemChain(Mock.vTaskGetRunTimeStats_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskGetRunTimeStats(cmock_call_instance, pcWriteBuffer);
}

TickType_t xTaskGetIdleRunTimeCounter(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetIdleRunTimeCounter);
  cmock_call_instance = (CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetIdleRunTimeCounter_CallInstance);
  Mock.xTaskGetIdleRunTimeCounter_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetIdleRunTimeCounter_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetIdleRunTimeCounter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE));
  CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetIdleRunTimeCounter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetIdleRunTimeCounter_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetIdleRunTimeCounter_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

BaseType_t xTaskGenericNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGenericNotify);
  cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGenericNotify_CallInstance);
  Mock.xTaskGenericNotify_CallInstance = CMock_Guts_MemNext(Mock.xTaskGenericNotify_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_xTaskToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_ulValue);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulValue, ulValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_eAction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction), sizeof(eNotifyAction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotify,CMockString_pulPreviousNotificationValue);
    if (cmock_call_instance->Expected_pulPreviousNotificationValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pulPreviousNotificationValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulPreviousNotificationValue, pulPreviousNotificationValue, cmock_call_instance->Expected_pulPreviousNotificationValue_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGenericNotify(CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, int pulPreviousNotificationValue_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify),
         sizeof(TaskHandle_t[sizeof(xTaskToNotify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ulValue = ulValue;
  memcpy((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction),
         sizeof(eNotifyAction[sizeof(eAction) == sizeof(eNotifyAction) ? 1 : -1])); /* add eNotifyAction to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pulPreviousNotificationValue = pulPreviousNotificationValue;
  cmock_call_instance->Expected_pulPreviousNotificationValue_Depth = pulPreviousNotificationValue_Depth;
}

void xTaskGenericNotify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotify_CALL_INSTANCE));
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotify_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGenericNotify(cmock_call_instance, xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGenericNotify_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, int pulPreviousNotificationValue_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotify_CALL_INSTANCE));
  CMOCK_xTaskGenericNotify_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotify_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGenericNotify(cmock_call_instance, xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pulPreviousNotificationValue_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

BaseType_t xTaskGenericNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGenericNotifyFromISR);
  cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGenericNotifyFromISR_CallInstance);
  Mock.xTaskGenericNotifyFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGenericNotifyFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_xTaskToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_ulValue);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulValue, ulValue, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_eAction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction), sizeof(eNotifyAction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_pulPreviousNotificationValue);
    if (cmock_call_instance->Expected_pulPreviousNotificationValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pulPreviousNotificationValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulPreviousNotificationValue, pulPreviousNotificationValue, cmock_call_instance->Expected_pulPreviousNotificationValue_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskGenericNotifyFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskGenericNotifyFromISR(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, int pulPreviousNotificationValue_Depth, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify),
         sizeof(TaskHandle_t[sizeof(xTaskToNotify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ulValue = ulValue;
  memcpy((void*)(&cmock_call_instance->Expected_eAction), (void*)(&eAction),
         sizeof(eNotifyAction[sizeof(eAction) == sizeof(eNotifyAction) ? 1 : -1])); /* add eNotifyAction to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pulPreviousNotificationValue = pulPreviousNotificationValue;
  cmock_call_instance->Expected_pulPreviousNotificationValue_Depth = pulPreviousNotificationValue_Depth;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
}

void xTaskGenericNotifyFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGenericNotifyFromISR(cmock_call_instance, xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, 1, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskGenericNotifyFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t* pulPreviousNotificationValue, int pulPreviousNotificationValue_Depth, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE));
  CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGenericNotifyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGenericNotifyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGenericNotifyFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskGenericNotifyFromISR(cmock_call_instance, xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pulPreviousNotificationValue_Depth, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskNotifyWait_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskNotifyWait);
  cmock_call_instance = (CMOCK_xTaskNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskNotifyWait_CallInstance);
  Mock.xTaskNotifyWait_CallInstance = CMock_Guts_MemNext(Mock.xTaskNotifyWait_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskNotifyWait,CMockString_ulBitsToClearOnEntry);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClearOnEntry, ulBitsToClearOnEntry, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskNotifyWait,CMockString_ulBitsToClearOnExit);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClearOnExit, ulBitsToClearOnExit, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskNotifyWait,CMockString_pulNotificationValue);
    if (cmock_call_instance->Expected_pulNotificationValue == NULL)
      { UNITY_TEST_ASSERT_NULL(pulNotificationValue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulNotificationValue, pulNotificationValue, cmock_call_instance->Expected_pulNotificationValue_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskNotifyWait,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskNotifyWait(CMOCK_xTaskNotifyWait_CALL_INSTANCE* cmock_call_instance, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, int pulNotificationValue_Depth, TickType_t xTicksToWait)
{
  cmock_call_instance->Expected_ulBitsToClearOnEntry = ulBitsToClearOnEntry;
  cmock_call_instance->Expected_ulBitsToClearOnExit = ulBitsToClearOnExit;
  cmock_call_instance->Expected_pulNotificationValue = pulNotificationValue;
  cmock_call_instance->Expected_pulNotificationValue_Depth = pulNotificationValue_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTaskNotifyWait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskNotifyWait_CALL_INSTANCE));
  CMOCK_xTaskNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskNotifyWait_CallInstance = CMock_Guts_MemChain(Mock.xTaskNotifyWait_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskNotifyWait(cmock_call_instance, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskNotifyWait_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t* pulNotificationValue, int pulNotificationValue_Depth, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskNotifyWait_CALL_INSTANCE));
  CMOCK_xTaskNotifyWait_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskNotifyWait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskNotifyWait_CallInstance = CMock_Guts_MemChain(Mock.xTaskNotifyWait_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskNotifyWait(cmock_call_instance, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, pulNotificationValue_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskNotifyGiveFromISR);
  cmock_call_instance = (CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskNotifyGiveFromISR_CallInstance);
  Mock.vTaskNotifyGiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.vTaskNotifyGiveFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskNotifyGiveFromISR,CMockString_xTaskToNotify);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskNotifyGiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskNotifyGiveFromISR(CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTaskToNotify, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTaskToNotify), (void*)(&xTaskToNotify),
         sizeof(TaskHandle_t[sizeof(xTaskToNotify) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
}

void vTaskNotifyGiveFromISR_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, BaseType_t* pxHigherPriorityTaskWoken)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE));
  CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskNotifyGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskNotifyGiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskNotifyGiveFromISR(cmock_call_instance, xTaskToNotify, pxHigherPriorityTaskWoken, 1);
}

void vTaskNotifyGiveFromISR_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTaskToNotify, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE));
  CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskNotifyGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskNotifyGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.vTaskNotifyGiveFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskNotifyGiveFromISR(cmock_call_instance, xTaskToNotify, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
}

uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulTaskNotifyTake_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulTaskNotifyTake);
  cmock_call_instance = (CMOCK_ulTaskNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulTaskNotifyTake_CallInstance);
  Mock.ulTaskNotifyTake_CallInstance = CMock_Guts_MemNext(Mock.ulTaskNotifyTake_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_ulTaskNotifyTake,CMockString_xClearCountOnExit);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xClearCountOnExit), (void*)(&xClearCountOnExit), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_ulTaskNotifyTake,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ulTaskNotifyTake(CMOCK_ulTaskNotifyTake_CALL_INSTANCE* cmock_call_instance, BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xClearCountOnExit), (void*)(&xClearCountOnExit),
         sizeof(BaseType_t[sizeof(xClearCountOnExit) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void ulTaskNotifyTake_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t xClearCountOnExit, TickType_t xTicksToWait, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulTaskNotifyTake_CALL_INSTANCE));
  CMOCK_ulTaskNotifyTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulTaskNotifyTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulTaskNotifyTake_CallInstance = CMock_Guts_MemChain(Mock.ulTaskNotifyTake_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_ulTaskNotifyTake(cmock_call_instance, xClearCountOnExit, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskNotifyStateClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskNotifyStateClear);
  cmock_call_instance = (CMOCK_xTaskNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskNotifyStateClear_CallInstance);
  Mock.xTaskNotifyStateClear_CallInstance = CMock_Guts_MemNext(Mock.xTaskNotifyStateClear_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskNotifyStateClear,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskNotifyStateClear(CMOCK_xTaskNotifyStateClear_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskNotifyStateClear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskNotifyStateClear_CALL_INSTANCE));
  CMOCK_xTaskNotifyStateClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskNotifyStateClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskNotifyStateClear_CallInstance = CMock_Guts_MemChain(Mock.xTaskNotifyStateClear_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskNotifyStateClear(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTaskIncrementTick(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskIncrementTick_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskIncrementTick);
  cmock_call_instance = (CMOCK_xTaskIncrementTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskIncrementTick_CallInstance);
  Mock.xTaskIncrementTick_CallInstance = CMock_Guts_MemNext(Mock.xTaskIncrementTick_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskIncrementTick_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskIncrementTick_CALL_INSTANCE));
  CMOCK_xTaskIncrementTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskIncrementTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskIncrementTick_CallInstance = CMock_Guts_MemChain(Mock.xTaskIncrementTick_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vTaskPlaceOnEventList(List_t* const pxEventList, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventList);
  cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPlaceOnEventList_CallInstance);
  Mock.vTaskPlaceOnEventList_CallInstance = CMock_Guts_MemNext(Mock.vTaskPlaceOnEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventList,CMockString_pxEventList);
    if (cmock_call_instance->Expected_pxEventList == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEventList, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(List_t), cmock_call_instance->Expected_pxEventList_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventList,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPlaceOnEventList(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance, List_t* const pxEventList, int pxEventList_Depth, const TickType_t xTicksToWait)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->Expected_pxEventList_Depth = pxEventList_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void vTaskPlaceOnEventList_CMockExpect(UNITY_LINE_TYPE cmock_line, List_t* const pxEventList, const TickType_t xTicksToWait)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPlaceOnEventList(cmock_call_instance, pxEventList, 1, xTicksToWait);
}

void vTaskPlaceOnEventList_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, List_t* const pxEventList, int pxEventList_Depth, const TickType_t xTicksToWait)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPlaceOnEventList(cmock_call_instance, pxEventList, pxEventList_Depth, xTicksToWait);
}

void vTaskPlaceOnUnorderedEventList(List_t* pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPlaceOnUnorderedEventList);
  cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPlaceOnUnorderedEventList_CallInstance);
  Mock.vTaskPlaceOnUnorderedEventList_CallInstance = CMock_Guts_MemNext(Mock.vTaskPlaceOnUnorderedEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnUnorderedEventList,CMockString_pxEventList);
    if (cmock_call_instance->Expected_pxEventList == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEventList, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(List_t), cmock_call_instance->Expected_pxEventList_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnUnorderedEventList,CMockString_xItemValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnUnorderedEventList,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPlaceOnUnorderedEventList(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance, List_t* pxEventList, int pxEventList_Depth, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->Expected_pxEventList_Depth = pxEventList_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue),
         sizeof(TickType_t[sizeof(xItemValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void vTaskPlaceOnUnorderedEventList_CMockExpect(UNITY_LINE_TYPE cmock_line, List_t* pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPlaceOnUnorderedEventList(cmock_call_instance, pxEventList, 1, xItemValue, xTicksToWait);
}

void vTaskPlaceOnUnorderedEventList_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, List_t* pxEventList, int pxEventList_Depth, const TickType_t xItemValue, const TickType_t xTicksToWait)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPlaceOnUnorderedEventList(cmock_call_instance, pxEventList, pxEventList_Depth, xItemValue, xTicksToWait);
}

void vTaskPlaceOnEventListRestricted(List_t* const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPlaceOnEventListRestricted);
  cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPlaceOnEventListRestricted_CallInstance);
  Mock.vTaskPlaceOnEventListRestricted_CallInstance = CMock_Guts_MemNext(Mock.vTaskPlaceOnEventListRestricted_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventListRestricted,CMockString_pxEventList);
    if (cmock_call_instance->Expected_pxEventList == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEventList, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(List_t), cmock_call_instance->Expected_pxEventList_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventListRestricted,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPlaceOnEventListRestricted,CMockString_xWaitIndefinitely);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPlaceOnEventListRestricted(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance, List_t* const pxEventList, int pxEventList_Depth, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->Expected_pxEventList_Depth = pxEventList_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely),
         sizeof(BaseType_t[sizeof(xWaitIndefinitely) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vTaskPlaceOnEventListRestricted_CMockExpect(UNITY_LINE_TYPE cmock_line, List_t* const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventListRestricted_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPlaceOnEventListRestricted(cmock_call_instance, pxEventList, 1, xTicksToWait, xWaitIndefinitely);
}

void vTaskPlaceOnEventListRestricted_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, List_t* const pxEventList, int pxEventList_Depth, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE));
  CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPlaceOnEventListRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPlaceOnEventListRestricted_CallInstance = CMock_Guts_MemChain(Mock.vTaskPlaceOnEventListRestricted_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPlaceOnEventListRestricted(cmock_call_instance, pxEventList, pxEventList_Depth, xTicksToWait, xWaitIndefinitely);
}

BaseType_t xTaskRemoveFromEventList(const List_t* const pxEventList)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskRemoveFromEventList);
  cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskRemoveFromEventList_CallInstance);
  Mock.xTaskRemoveFromEventList_CallInstance = CMock_Guts_MemNext(Mock.xTaskRemoveFromEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskRemoveFromEventList,CMockString_pxEventList);
    if (cmock_call_instance->Expected_pxEventList == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEventList, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEventList), (void*)(pxEventList), sizeof(const List_t), cmock_call_instance->Expected_pxEventList_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskRemoveFromEventList(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance, const List_t* const pxEventList, int pxEventList_Depth)
{
  cmock_call_instance->Expected_pxEventList = pxEventList;
  cmock_call_instance->Expected_pxEventList_Depth = pxEventList_Depth;
}

void xTaskRemoveFromEventList_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const List_t* const pxEventList, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE));
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskRemoveFromEventList_CallInstance = CMock_Guts_MemChain(Mock.xTaskRemoveFromEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskRemoveFromEventList(cmock_call_instance, pxEventList, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskRemoveFromEventList_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const List_t* const pxEventList, int pxEventList_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE));
  CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskRemoveFromEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskRemoveFromEventList_CallInstance = CMock_Guts_MemChain(Mock.xTaskRemoveFromEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskRemoveFromEventList(cmock_call_instance, pxEventList, pxEventList_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTaskRemoveFromUnorderedEventList(ListItem_t* pxEventListItem, const TickType_t xItemValue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskRemoveFromUnorderedEventList);
  cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskRemoveFromUnorderedEventList_CallInstance);
  Mock.vTaskRemoveFromUnorderedEventList_CallInstance = CMock_Guts_MemNext(Mock.vTaskRemoveFromUnorderedEventList_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskRemoveFromUnorderedEventList,CMockString_pxEventListItem);
    if (cmock_call_instance->Expected_pxEventListItem == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEventListItem, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEventListItem), (void*)(pxEventListItem), sizeof(ListItem_t), cmock_call_instance->Expected_pxEventListItem_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskRemoveFromUnorderedEventList,CMockString_xItemValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskRemoveFromUnorderedEventList(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance, ListItem_t* pxEventListItem, int pxEventListItem_Depth, const TickType_t xItemValue)
{
  cmock_call_instance->Expected_pxEventListItem = pxEventListItem;
  cmock_call_instance->Expected_pxEventListItem_Depth = pxEventListItem_Depth;
  memcpy((void*)(&cmock_call_instance->Expected_xItemValue), (void*)(&xItemValue),
         sizeof(TickType_t[sizeof(xItemValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void vTaskRemoveFromUnorderedEventList_CMockExpect(UNITY_LINE_TYPE cmock_line, ListItem_t* pxEventListItem, const TickType_t xItemValue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskRemoveFromUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskRemoveFromUnorderedEventList(cmock_call_instance, pxEventListItem, 1, xItemValue);
}

void vTaskRemoveFromUnorderedEventList_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, ListItem_t* pxEventListItem, int pxEventListItem_Depth, const TickType_t xItemValue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE));
  CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskRemoveFromUnorderedEventList_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskRemoveFromUnorderedEventList_CallInstance = CMock_Guts_MemChain(Mock.vTaskRemoveFromUnorderedEventList_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskRemoveFromUnorderedEventList(cmock_call_instance, pxEventListItem, pxEventListItem_Depth, xItemValue);
}

void vTaskSwitchContext(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSwitchContext_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSwitchContext);
  cmock_call_instance = (CMOCK_vTaskSwitchContext_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSwitchContext_CallInstance);
  Mock.vTaskSwitchContext_CallInstance = CMock_Guts_MemNext(Mock.vTaskSwitchContext_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskSwitchContext_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSwitchContext_CALL_INSTANCE));
  CMOCK_vTaskSwitchContext_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSwitchContext_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSwitchContext_CallInstance = CMock_Guts_MemChain(Mock.vTaskSwitchContext_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

TickType_t uxTaskResetEventItemValue(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskResetEventItemValue);
  cmock_call_instance = (CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskResetEventItemValue_CallInstance);
  Mock.uxTaskResetEventItemValue_CallInstance = CMock_Guts_MemNext(Mock.uxTaskResetEventItemValue_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void uxTaskResetEventItemValue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE));
  CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskResetEventItemValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskResetEventItemValue_CallInstance = CMock_Guts_MemChain(Mock.uxTaskResetEventItemValue_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

TaskHandle_t xTaskGetCurrentTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetCurrentTaskHandle);
  cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetCurrentTaskHandle_CallInstance);
  Mock.xTaskGetCurrentTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetCurrentTaskHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetCurrentTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE));
  CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetCurrentTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetCurrentTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetCurrentTaskHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void vTaskSetTimeOutState(TimeOut_t* const pxTimeOut)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetTimeOutState);
  cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetTimeOutState_CallInstance);
  Mock.vTaskSetTimeOutState_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetTimeOutState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetTimeOutState,CMockString_pxTimeOut);
    if (cmock_call_instance->Expected_pxTimeOut == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTimeOut, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTimeOut), (void*)(pxTimeOut), sizeof(TimeOut_t), cmock_call_instance->Expected_pxTimeOut_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetTimeOutState(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut, int pxTimeOut_Depth)
{
  cmock_call_instance->Expected_pxTimeOut = pxTimeOut;
  cmock_call_instance->Expected_pxTimeOut_Depth = pxTimeOut_Depth;
}

void vTaskSetTimeOutState_CMockExpect(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSetTimeOutState(cmock_call_instance, pxTimeOut, 1);
}

void vTaskSetTimeOutState_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut, int pxTimeOut_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSetTimeOutState(cmock_call_instance, pxTimeOut, pxTimeOut_Depth);
}

BaseType_t xTaskCheckForTimeOut(TimeOut_t* const pxTimeOut, TickType_t* const pxTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCheckForTimeOut);
  cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCheckForTimeOut_CallInstance);
  Mock.xTaskCheckForTimeOut_CallInstance = CMock_Guts_MemNext(Mock.xTaskCheckForTimeOut_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskCheckForTimeOut,CMockString_pxTimeOut);
    if (cmock_call_instance->Expected_pxTimeOut == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTimeOut, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTimeOut), (void*)(pxTimeOut), sizeof(TimeOut_t), cmock_call_instance->Expected_pxTimeOut_Depth, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTaskCheckForTimeOut,CMockString_pxTicksToWait);
    if (cmock_call_instance->Expected_pxTicksToWait == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTicksToWait, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTicksToWait), (void*)(pxTicksToWait), sizeof(TickType_t), cmock_call_instance->Expected_pxTicksToWait_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCheckForTimeOut(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut, int pxTimeOut_Depth, TickType_t* const pxTicksToWait, int pxTicksToWait_Depth)
{
  cmock_call_instance->Expected_pxTimeOut = pxTimeOut;
  cmock_call_instance->Expected_pxTimeOut_Depth = pxTimeOut_Depth;
  cmock_call_instance->Expected_pxTicksToWait = pxTicksToWait;
  cmock_call_instance->Expected_pxTicksToWait_Depth = pxTicksToWait_Depth;
}

void xTaskCheckForTimeOut_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut, TickType_t* const pxTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE));
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCheckForTimeOut_CallInstance = CMock_Guts_MemChain(Mock.xTaskCheckForTimeOut_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCheckForTimeOut(cmock_call_instance, pxTimeOut, 1, pxTicksToWait, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCheckForTimeOut_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut, int pxTimeOut_Depth, TickType_t* const pxTicksToWait, int pxTicksToWait_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE));
  CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCheckForTimeOut_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCheckForTimeOut_CallInstance = CMock_Guts_MemChain(Mock.xTaskCheckForTimeOut_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskCheckForTimeOut(cmock_call_instance, pxTimeOut, pxTimeOut_Depth, pxTicksToWait, pxTicksToWait_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTaskMissedYield(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskMissedYield_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskMissedYield);
  cmock_call_instance = (CMOCK_vTaskMissedYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskMissedYield_CallInstance);
  Mock.vTaskMissedYield_CallInstance = CMock_Guts_MemNext(Mock.vTaskMissedYield_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void vTaskMissedYield_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskMissedYield_CALL_INSTANCE));
  CMOCK_vTaskMissedYield_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskMissedYield_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskMissedYield_CallInstance = CMock_Guts_MemChain(Mock.vTaskMissedYield_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

BaseType_t xTaskGetSchedulerState(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetSchedulerState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetSchedulerState);
  cmock_call_instance = (CMOCK_xTaskGetSchedulerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetSchedulerState_CallInstance);
  Mock.xTaskGetSchedulerState_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetSchedulerState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetSchedulerState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetSchedulerState_CALL_INSTANCE));
  CMOCK_xTaskGetSchedulerState_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetSchedulerState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetSchedulerState_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetSchedulerState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskPriorityInherit);
  cmock_call_instance = (CMOCK_xTaskPriorityInherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskPriorityInherit_CallInstance);
  Mock.xTaskPriorityInherit_CallInstance = CMock_Guts_MemNext(Mock.xTaskPriorityInherit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskPriorityInherit,CMockString_pxMutexHolder);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskPriorityInherit(CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t pxMutexHolder)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder),
         sizeof(TaskHandle_t[sizeof(pxMutexHolder) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskPriorityInherit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t const pxMutexHolder, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskPriorityInherit_CALL_INSTANCE));
  CMOCK_xTaskPriorityInherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityInherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskPriorityInherit_CallInstance = CMock_Guts_MemChain(Mock.xTaskPriorityInherit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskPriorityInherit(cmock_call_instance, pxMutexHolder);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskPriorityDisinherit);
  cmock_call_instance = (CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskPriorityDisinherit_CallInstance);
  Mock.xTaskPriorityDisinherit_CallInstance = CMock_Guts_MemNext(Mock.xTaskPriorityDisinherit_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTaskPriorityDisinherit,CMockString_pxMutexHolder);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskPriorityDisinherit(CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t pxMutexHolder)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder),
         sizeof(TaskHandle_t[sizeof(pxMutexHolder) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTaskPriorityDisinherit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t const pxMutexHolder, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE));
  CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskPriorityDisinherit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskPriorityDisinherit_CallInstance = CMock_Guts_MemChain(Mock.xTaskPriorityDisinherit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTaskPriorityDisinherit(cmock_call_instance, pxMutexHolder);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vTaskPriorityDisinheritAfterTimeout(TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskPriorityDisinheritAfterTimeout);
  cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance);
  Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance = CMock_Guts_MemNext(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskPriorityDisinheritAfterTimeout,CMockString_pxMutexHolder);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskPriorityDisinheritAfterTimeout,CMockString_uxHighestPriorityWaitingTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxHighestPriorityWaitingTask), (void*)(&uxHighestPriorityWaitingTask), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskPriorityDisinheritAfterTimeout(CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance, const TaskHandle_t pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxMutexHolder), (void*)(&pxMutexHolder),
         sizeof(TaskHandle_t[sizeof(pxMutexHolder) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxHighestPriorityWaitingTask), (void*)(&uxHighestPriorityWaitingTask),
         sizeof(UBaseType_t[sizeof(uxHighestPriorityWaitingTask) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTaskPriorityDisinheritAfterTimeout_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE));
  CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskPriorityDisinheritAfterTimeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance = CMock_Guts_MemChain(Mock.vTaskPriorityDisinheritAfterTimeout_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskPriorityDisinheritAfterTimeout(cmock_call_instance, pxMutexHolder, uxHighestPriorityWaitingTask);
}

UBaseType_t uxTaskGetTaskNumber(TaskHandle_t xTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTaskGetTaskNumber);
  cmock_call_instance = (CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTaskGetTaskNumber_CallInstance);
  Mock.uxTaskGetTaskNumber_CallInstance = CMock_Guts_MemNext(Mock.uxTaskGetTaskNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTaskGetTaskNumber,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTaskGetTaskNumber(CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void uxTaskGetTaskNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE));
  CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTaskGetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTaskGetTaskNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTaskGetTaskNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTaskGetTaskNumber(cmock_call_instance, xTask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTaskSetTaskNumber(TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskSetTaskNumber);
  cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskSetTaskNumber_CallInstance);
  Mock.vTaskSetTaskNumber_CallInstance = CMock_Guts_MemNext(Mock.vTaskSetTaskNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetTaskNumber,CMockString_xTask);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask), sizeof(TaskHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTaskSetTaskNumber,CMockString_uxHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxHandle), (void*)(&uxHandle), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskSetTaskNumber(CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance, TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTask), (void*)(&xTask),
         sizeof(TaskHandle_t[sizeof(xTask) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxHandle), (void*)(&uxHandle),
         sizeof(UBaseType_t[sizeof(uxHandle) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTaskSetTaskNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, TaskHandle_t xTask, const UBaseType_t uxHandle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskSetTaskNumber_CALL_INSTANCE));
  CMOCK_vTaskSetTaskNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskSetTaskNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskSetTaskNumber_CallInstance = CMock_Guts_MemChain(Mock.vTaskSetTaskNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskSetTaskNumber(cmock_call_instance, xTask, uxHandle);
}

void vTaskStepTick(const TickType_t xTicksToJump)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskStepTick);
  cmock_call_instance = (CMOCK_vTaskStepTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskStepTick_CallInstance);
  Mock.vTaskStepTick_CallInstance = CMock_Guts_MemNext(Mock.vTaskStepTick_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskStepTick,CMockString_xTicksToJump);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToJump), (void*)(&xTicksToJump), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskStepTick(CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance, const TickType_t xTicksToJump)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToJump), (void*)(&xTicksToJump),
         sizeof(TickType_t[sizeof(xTicksToJump) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void vTaskStepTick_CMockExpect(UNITY_LINE_TYPE cmock_line, const TickType_t xTicksToJump)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskStepTick_CALL_INSTANCE));
  CMOCK_vTaskStepTick_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskStepTick_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskStepTick_CallInstance = CMock_Guts_MemChain(Mock.vTaskStepTick_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskStepTick(cmock_call_instance, xTicksToJump);
}

eSleepModeStatus eTaskConfirmSleepModeStatus(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eTaskConfirmSleepModeStatus);
  cmock_call_instance = (CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eTaskConfirmSleepModeStatus_CallInstance);
  Mock.eTaskConfirmSleepModeStatus_CallInstance = CMock_Guts_MemNext(Mock.eTaskConfirmSleepModeStatus_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void eTaskConfirmSleepModeStatus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, eSleepModeStatus cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE));
  CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_eTaskConfirmSleepModeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eTaskConfirmSleepModeStatus_CallInstance = CMock_Guts_MemChain(Mock.eTaskConfirmSleepModeStatus_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eSleepModeStatus[sizeof(cmock_to_return) == sizeof(eSleepModeStatus) ? 1 : -1])); /* add eSleepModeStatus to :treat_as_array if this causes an error */
}

TaskHandle_t pvTaskIncrementMutexHeldCount(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTaskIncrementMutexHeldCount);
  cmock_call_instance = (CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTaskIncrementMutexHeldCount_CallInstance);
  Mock.pvTaskIncrementMutexHeldCount_CallInstance = CMock_Guts_MemNext(Mock.pvTaskIncrementMutexHeldCount_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void pvTaskIncrementMutexHeldCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE));
  CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTaskIncrementMutexHeldCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTaskIncrementMutexHeldCount_CallInstance = CMock_Guts_MemChain(Mock.pvTaskIncrementMutexHeldCount_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void vTaskInternalSetTimeOutState(TimeOut_t* const pxTimeOut)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskInternalSetTimeOutState);
  cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskInternalSetTimeOutState_CallInstance);
  Mock.vTaskInternalSetTimeOutState_CallInstance = CMock_Guts_MemNext(Mock.vTaskInternalSetTimeOutState_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTaskInternalSetTimeOutState,CMockString_pxTimeOut);
    if (cmock_call_instance->Expected_pxTimeOut == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTimeOut, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTimeOut), (void*)(pxTimeOut), sizeof(TimeOut_t), cmock_call_instance->Expected_pxTimeOut_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskInternalSetTimeOutState(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance, TimeOut_t* const pxTimeOut, int pxTimeOut_Depth)
{
  cmock_call_instance->Expected_pxTimeOut = pxTimeOut;
  cmock_call_instance->Expected_pxTimeOut_Depth = pxTimeOut_Depth;
}

void vTaskInternalSetTimeOutState_CMockExpect(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskInternalSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskInternalSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskInternalSetTimeOutState(cmock_call_instance, pxTimeOut, 1);
}

void vTaskInternalSetTimeOutState_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TimeOut_t* const pxTimeOut, int pxTimeOut_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE));
  CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskInternalSetTimeOutState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskInternalSetTimeOutState_CallInstance = CMock_Guts_MemChain(Mock.vTaskInternalSetTimeOutState_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTaskInternalSetTimeOutState(cmock_call_instance, pxTimeOut, pxTimeOut_Depth);
}

