/* AUTOGENERATED FILE. DO NOT EDIT. */
#include "Mocktimers.h"

#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#include "FreeRTOS.h"
#include "cmock.h"

static const char* CMockString_pcTimerGetName = "pcTimerGetName";
static const char* CMockString_pcTimerName = "pcTimerName";
static const char* CMockString_pvNewID = "pvNewID";
static const char* CMockString_pvParameter1 = "pvParameter1";
static const char* CMockString_pvTimerGetTimerID = "pvTimerGetTimerID";
static const char* CMockString_pvTimerID = "pvTimerID";
static const char* CMockString_pxCallbackFunction = "pxCallbackFunction";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxTimerBuffer = "pxTimerBuffer";
static const char* CMockString_ulParameter2 = "ulParameter2";
static const char* CMockString_uxAutoReload = "uxAutoReload";
static const char* CMockString_uxTimerGetTimerNumber = "uxTimerGetTimerNumber";
static const char* CMockString_uxTimerNumber = "uxTimerNumber";
static const char* CMockString_vTimerSetReloadMode = "vTimerSetReloadMode";
static const char* CMockString_vTimerSetTimerID = "vTimerSetTimerID";
static const char* CMockString_vTimerSetTimerNumber = "vTimerSetTimerNumber";
static const char* CMockString_xCommandID = "xCommandID";
static const char* CMockString_xFunctionToPend = "xFunctionToPend";
static const char* CMockString_xOptionalValue = "xOptionalValue";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTimer = "xTimer";
static const char* CMockString_xTimerCreate = "xTimerCreate";
static const char* CMockString_xTimerCreateStatic = "xTimerCreateStatic";
static const char* CMockString_xTimerCreateTimerTask = "xTimerCreateTimerTask";
static const char* CMockString_xTimerGenericCommand = "xTimerGenericCommand";
static const char* CMockString_xTimerGetExpiryTime = "xTimerGetExpiryTime";
static const char* CMockString_xTimerGetPeriod = "xTimerGetPeriod";
static const char* CMockString_xTimerGetTimerDaemonTaskHandle = "xTimerGetTimerDaemonTaskHandle";
static const char* CMockString_xTimerIsTimerActive = "xTimerIsTimerActive";
static const char* CMockString_xTimerPendFunctionCall = "xTimerPendFunctionCall";
static const char* CMockString_xTimerPendFunctionCallFromISR = "xTimerPendFunctionCallFromISR";
static const char* CMockString_xTimerPeriodInTicks = "xTimerPeriodInTicks";

typedef struct _CMOCK_xTimerCreate_CALL_INSTANCE {
    UNITY_LINE_TYPE LineNumber;
    TimerHandle_t ReturnVal;
    const char* Expected_pcTimerName;
    TickType_t Expected_xTimerPeriodInTicks;
    UBaseType_t Expected_uxAutoReload;
    void* Expected_pvTimerID;
    TimerCallbackFunction_t Expected_pxCallbackFunction;

} CMOCK_xTimerCreate_CALL_INSTANCE;

typedef struct _CMOCK_xTimerCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimerHandle_t ReturnVal;
  const char* Expected_pcTimerName;
  TickType_t Expected_xTimerPeriodInTicks;
  UBaseType_t Expected_uxAutoReload;
  void* Expected_pvTimerID;
  TimerCallbackFunction_t Expected_pxCallbackFunction;
  StaticTimer_t* Expected_pxTimerBuffer;

} CMOCK_xTimerCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_pvTimerGetTimerID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  void* ReturnVal;
  TimerHandle_t Expected_xTimer;

} CMOCK_pvTimerGetTimerID_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetTimerID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimerHandle_t Expected_xTimer;
  void* Expected_pvNewID;

} CMOCK_vTimerSetTimerID_CALL_INSTANCE;

typedef struct _CMOCK_xTimerIsTimerActive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TimerHandle_t Expected_xTimer;

} CMOCK_xTimerIsTimerActive_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;

} CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  PendedFunction_t Expected_xFunctionToPend;
  void* Expected_pvParameter1;
  uint32_t Expected_ulParameter2;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xTimerPendFunctionCall_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  PendedFunction_t Expected_xFunctionToPend;
  void* Expected_pvParameter1;
  uint32_t Expected_ulParameter2;
  TickType_t Expected_xTicksToWait;

} CMOCK_xTimerPendFunctionCall_CALL_INSTANCE;

typedef struct _CMOCK_pcTimerGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* ReturnVal;
  TimerHandle_t Expected_xTimer;

} CMOCK_pcTimerGetName_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetReloadMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimerHandle_t Expected_xTimer;
  UBaseType_t Expected_uxAutoReload;

} CMOCK_vTimerSetReloadMode_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetPeriod_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;
  TimerHandle_t Expected_xTimer;

} CMOCK_xTimerGetPeriod_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetExpiryTime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;
  TimerHandle_t Expected_xTimer;

} CMOCK_xTimerGetExpiryTime_CALL_INSTANCE;

typedef struct _CMOCK_xTimerCreateTimerTask_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;

} CMOCK_xTimerCreateTimerTask_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGenericCommand_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  TimerHandle_t Expected_xTimer;
  BaseType_t Expected_xCommandID;
  TickType_t Expected_xOptionalValue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  TickType_t Expected_xTicksToWait;

} CMOCK_xTimerGenericCommand_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetTimerNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimerHandle_t Expected_xTimer;
  UBaseType_t Expected_uxTimerNumber;

} CMOCK_vTimerSetTimerNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  TimerHandle_t Expected_xTimer;

} CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE;

static struct MocktimersInstance
{
  CMOCK_MEM_INDEX_TYPE xTimerCreate_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerCreateStatic_CallInstance;
  CMOCK_MEM_INDEX_TYPE pvTimerGetTimerID_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTimerSetTimerID_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerIsTimerActive_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerGetTimerDaemonTaskHandle_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerPendFunctionCallFromISR_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerPendFunctionCall_CallInstance;
  CMOCK_MEM_INDEX_TYPE pcTimerGetName_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTimerSetReloadMode_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerGetPeriod_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerGetExpiryTime_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerCreateTimerTask_CallInstance;
  CMOCK_MEM_INDEX_TYPE xTimerGenericCommand_CallInstance;
  CMOCK_MEM_INDEX_TYPE vTimerSetTimerNumber_CallInstance;
  CMOCK_MEM_INDEX_TYPE uxTimerGetTimerNumber_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocktimers_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xTimerCreate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerCreateStatic_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pvTimerGetTimerID_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTimerGetTimerID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTimerSetTimerID_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetTimerID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerIsTimerActive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerIsTimerActive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGetTimerDaemonTaskHandle_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetTimerDaemonTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerPendFunctionCallFromISR_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCallFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerPendFunctionCall_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCall);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pcTimerGetName_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcTimerGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTimerSetReloadMode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetReloadMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGetPeriod_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetPeriod);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGetExpiryTime_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetExpiryTime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerCreateTimerTask_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreateTimerTask);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGenericCommand_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGenericCommand);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTimerSetTimerNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetTimerNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTimerGetTimerNumber_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTimerGetTimerNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mocktimers_Init(void)
{
  Mocktimers_Destroy();
}

void Mocktimers_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

TimerHandle_t xTimerCreate(const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreate);
  cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreate_CallInstance);
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pcTimerName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTimerName, pcTimerName, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_xTimerPeriodInTicks);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pvTimerID);
    if (cmock_call_instance->Expected_pvTimerID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTimerID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTimerID, pvTimerID, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pxCallbackFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction), sizeof(TimerCallbackFunction_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerCreate(CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  cmock_call_instance->Expected_pcTimerName = pcTimerName;
  memcpy((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks),
         sizeof(TickType_t[sizeof(xTimerPeriodInTicks) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvTimerID = pvTimerID;
  memcpy((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction),
         sizeof(TimerCallbackFunction_t[sizeof(pxCallbackFunction) == sizeof(TimerCallbackFunction_t) ? 1 : -1])); /* add TimerCallbackFunction_t to :treat_as_array if this causes an error */
}

void xTimerCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerCreate(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TimerHandle_t[sizeof(cmock_to_return) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

TimerHandle_t xTimerCreateStatic(const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreateStatic);
  cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreateStatic_CallInstance);
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateStatic_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pcTimerName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTimerName, pcTimerName, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_xTimerPeriodInTicks);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pvTimerID);
    if (cmock_call_instance->Expected_pvTimerID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTimerID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTimerID, pvTimerID, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pxCallbackFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction), sizeof(TimerCallbackFunction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pxTimerBuffer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxTimerBuffer), (void*)(pxTimerBuffer), sizeof(StaticTimer_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerCreateStatic(CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer)
{
  cmock_call_instance->Expected_pcTimerName = pcTimerName;
  memcpy((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks),
         sizeof(TickType_t[sizeof(xTimerPeriodInTicks) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvTimerID = pvTimerID;
  memcpy((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction),
         sizeof(TimerCallbackFunction_t[sizeof(pxCallbackFunction) == sizeof(TimerCallbackFunction_t) ? 1 : -1])); /* add TimerCallbackFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxTimerBuffer = pxTimerBuffer;
}

void xTimerCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerCreateStatic(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TimerHandle_t[sizeof(cmock_to_return) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void* pvTimerGetTimerID(const TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTimerGetTimerID);
  cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTimerGetTimerID_CallInstance);
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemNext(Mock.pvTimerGetTimerID_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_pvTimerGetTimerID,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pvTimerGetTimerID(CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance, const TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void pvTimerGetTimerID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TimerHandle_t xTimer, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTimerGetTimerID_CALL_INSTANCE));
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemChain(Mock.pvTimerGetTimerID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pvTimerGetTimerID(cmock_call_instance, xTimer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTimerSetTimerID(TimerHandle_t xTimer, void* pvNewID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetTimerID);
  cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetTimerID_CallInstance);
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetTimerID_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerID,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerID,CMockString_pvNewID);
    if (cmock_call_instance->Expected_pvNewID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvNewID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvNewID, pvNewID, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetTimerID(CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, void* pvNewID)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvNewID = pvNewID;
}

void vTimerSetTimerID_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, void* pvNewID)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerID_CALL_INSTANCE));
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTimerSetTimerID(cmock_call_instance, xTimer, pvNewID);
}

BaseType_t xTimerIsTimerActive(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerIsTimerActive);
  cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerIsTimerActive_CallInstance);
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemNext(Mock.xTimerIsTimerActive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerIsTimerActive,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerIsTimerActive(CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerIsTimerActive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerIsTimerActive_CALL_INSTANCE));
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemChain(Mock.xTimerIsTimerActive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerIsTimerActive(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

TaskHandle_t xTimerGetTimerDaemonTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetTimerDaemonTaskHandle);
  cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTimerGetTimerDaemonTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE));
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCallFromISR);
  cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_xFunctionToPend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend), sizeof(PendedFunction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_pvParameter1);
    if (cmock_call_instance->Expected_pvParameter1 == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter1, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter1, pvParameter1, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_ulParameter2);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulParameter2, ulParameter2, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerPendFunctionCallFromISR(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend),
         sizeof(PendedFunction_t[sizeof(xFunctionToPend) == sizeof(PendedFunction_t) ? 1 : -1])); /* add PendedFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvParameter1 = pvParameter1;
  cmock_call_instance->Expected_ulParameter2 = ulParameter2;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
}

void xTimerPendFunctionCallFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerPendFunctionCallFromISR(cmock_call_instance, xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCall);
  cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerPendFunctionCall_CallInstance);
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCall_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_xFunctionToPend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend), sizeof(PendedFunction_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_pvParameter1);
    if (cmock_call_instance->Expected_pvParameter1 == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter1, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter1, pvParameter1, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_ulParameter2);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulParameter2, ulParameter2, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerPendFunctionCall(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend),
         sizeof(PendedFunction_t[sizeof(xFunctionToPend) == sizeof(PendedFunction_t) ? 1 : -1])); /* add PendedFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pvParameter1 = pvParameter1;
  cmock_call_instance->Expected_ulParameter2 = ulParameter2;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTimerPendFunctionCall_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerPendFunctionCall(cmock_call_instance, xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

const char* pcTimerGetName(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcTimerGetName);
  cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcTimerGetName_CallInstance);
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemNext(Mock.pcTimerGetName_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_pcTimerGetName,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcTimerGetName(CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void pcTimerGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTimerGetName_CALL_INSTANCE));
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTimerGetName_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pcTimerGetName(cmock_call_instance, xTimer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vTimerSetReloadMode(TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetReloadMode);
  cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetReloadMode_CallInstance);
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetReloadMode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetReloadMode,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetReloadMode,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetReloadMode(CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTimerSetReloadMode_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetReloadMode_CALL_INSTANCE));
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetReloadMode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTimerSetReloadMode(cmock_call_instance, xTimer, uxAutoReload);
}

TickType_t xTimerGetPeriod(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetPeriod);
  cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetPeriod_CallInstance);
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetPeriod_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerGetPeriod,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGetPeriod(CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerGetPeriod_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetPeriod_CALL_INSTANCE));
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetPeriod_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerGetPeriod(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

TickType_t xTimerGetExpiryTime(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetExpiryTime);
  cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetExpiryTime_CallInstance);
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetExpiryTime_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerGetExpiryTime,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGetExpiryTime(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerGetExpiryTime_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE));
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetExpiryTime_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerGetExpiryTime(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

BaseType_t xTimerCreateTimerTask(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreateTimerTask);
  cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreateTimerTask_CallInstance);
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateTimerTask_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTimerCreateTimerTask_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateTimerTask_CALL_INSTANCE));
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateTimerTask_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTimerGenericCommand(TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGenericCommand);
  cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGenericCommand_CallInstance);
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemNext(Mock.xTimerGenericCommand_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xCommandID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCommandID), (void*)(&xCommandID), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xOptionalValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xOptionalValue), (void*)(&xOptionalValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_pxHigherPriorityTaskWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGenericCommand(CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xCommandID), (void*)(&xCommandID),
         sizeof(BaseType_t[sizeof(xCommandID) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_xOptionalValue), (void*)(&xOptionalValue),
         sizeof(TickType_t[sizeof(xOptionalValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTimerGenericCommand_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_xTimerGenericCommand(cmock_call_instance, xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void vTimerSetTimerNumber(TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetTimerNumber);
  cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetTimerNumber_CallInstance);
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetTimerNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerNumber,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerNumber,CMockString_uxTimerNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxTimerNumber), (void*)(&uxTimerNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetTimerNumber(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_uxTimerNumber), (void*)(&uxTimerNumber),
         sizeof(UBaseType_t[sizeof(uxTimerNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void vTimerSetTimerNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE));
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_vTimerSetTimerNumber(cmock_call_instance, xTimer, uxTimerNumber);
}

UBaseType_t uxTimerGetTimerNumber(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTimerGetTimerNumber);
  cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTimerGetTimerNumber_CallInstance);
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.uxTimerGetTimerNumber_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_uxTimerGetTimerNumber,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTimerGetTimerNumber(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void uxTimerGetTimerNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE));
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetTimerNumber_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_uxTimerGetTimerNumber(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

