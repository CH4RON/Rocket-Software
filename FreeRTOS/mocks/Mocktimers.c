/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mocktimers.h"

static const char* CMockString_pcTimerGetName = "pcTimerGetName";
static const char* CMockString_pcTimerName = "pcTimerName";
static const char* CMockString_pvNewID = "pvNewID";
static const char* CMockString_pvParameter1 = "pvParameter1";
static const char* CMockString_pvTimerGetTimerID = "pvTimerGetTimerID";
static const char* CMockString_pvTimerID = "pvTimerID";
static const char* CMockString_pxCallbackFunction = "pxCallbackFunction";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxTimerBuffer = "pxTimerBuffer";
static const char* CMockString_ulParameter2 = "ulParameter2";
static const char* CMockString_uxAutoReload = "uxAutoReload";
static const char* CMockString_uxTimerGetTimerNumber = "uxTimerGetTimerNumber";
static const char* CMockString_uxTimerNumber = "uxTimerNumber";
static const char* CMockString_vTimerSetReloadMode = "vTimerSetReloadMode";
static const char* CMockString_vTimerSetTimerID = "vTimerSetTimerID";
static const char* CMockString_vTimerSetTimerNumber = "vTimerSetTimerNumber";
static const char* CMockString_xCommandID = "xCommandID";
static const char* CMockString_xFunctionToPend = "xFunctionToPend";
static const char* CMockString_xOptionalValue = "xOptionalValue";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTimer = "xTimer";
static const char* CMockString_xTimerCreate = "xTimerCreate";
static const char* CMockString_xTimerCreateStatic = "xTimerCreateStatic";
static const char* CMockString_xTimerCreateTimerTask = "xTimerCreateTimerTask";
static const char* CMockString_xTimerGenericCommand = "xTimerGenericCommand";
static const char* CMockString_xTimerGetExpiryTime = "xTimerGetExpiryTime";
static const char* CMockString_xTimerGetPeriod = "xTimerGetPeriod";
static const char* CMockString_xTimerGetTimerDaemonTaskHandle = "xTimerGetTimerDaemonTaskHandle";
static const char* CMockString_xTimerIsTimerActive = "xTimerIsTimerActive";
static const char* CMockString_xTimerPendFunctionCall = "xTimerPendFunctionCall";
static const char* CMockString_xTimerPendFunctionCallFromISR = "xTimerPendFunctionCallFromISR";
static const char* CMockString_xTimerPeriodInTicks = "xTimerPeriodInTicks";

typedef struct _CMOCK_xTimerCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimerHandle_t ReturnVal;
  const char* Expected_pcTimerName;
  TickType_t Expected_xTimerPeriodInTicks;
  UBaseType_t Expected_uxAutoReload;
  void* Expected_pvTimerID;
  TimerCallbackFunction_t Expected_pxCallbackFunction;
  int Expected_pvTimerID_Depth;
  char IgnoreArg_pcTimerName;
  char IgnoreArg_xTimerPeriodInTicks;
  char IgnoreArg_uxAutoReload;
  char IgnoreArg_pvTimerID;
  char IgnoreArg_pxCallbackFunction;

} CMOCK_xTimerCreate_CALL_INSTANCE;

typedef struct _CMOCK_xTimerCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimerHandle_t ReturnVal;
  const char* Expected_pcTimerName;
  TickType_t Expected_xTimerPeriodInTicks;
  UBaseType_t Expected_uxAutoReload;
  void* Expected_pvTimerID;
  TimerCallbackFunction_t Expected_pxCallbackFunction;
  StaticTimer_t* Expected_pxTimerBuffer;
  int Expected_pvTimerID_Depth;
  int Expected_pxTimerBuffer_Depth;
  char IgnoreArg_pcTimerName;
  char IgnoreArg_xTimerPeriodInTicks;
  char IgnoreArg_uxAutoReload;
  char IgnoreArg_pvTimerID;
  char IgnoreArg_pxCallbackFunction;
  char IgnoreArg_pxTimerBuffer;

} CMOCK_xTimerCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_pvTimerGetTimerID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  void* ReturnVal;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_pvTimerGetTimerID_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetTimerID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimerHandle_t Expected_xTimer;
  void* Expected_pvNewID;
  int Expected_pvNewID_Depth;
  char IgnoreArg_xTimer;
  char IgnoreArg_pvNewID;

} CMOCK_vTimerSetTimerID_CALL_INSTANCE;

typedef struct _CMOCK_xTimerIsTimerActive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_xTimerIsTimerActive_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;

} CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  PendedFunction_t Expected_xFunctionToPend;
  void* Expected_pvParameter1;
  uint32_t Expected_ulParameter2;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pvParameter1_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char IgnoreArg_xFunctionToPend;
  char IgnoreArg_pvParameter1;
  char IgnoreArg_ulParameter2;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xTimerPendFunctionCall_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  PendedFunction_t Expected_xFunctionToPend;
  void* Expected_pvParameter1;
  uint32_t Expected_ulParameter2;
  TickType_t Expected_xTicksToWait;
  int Expected_pvParameter1_Depth;
  char IgnoreArg_xFunctionToPend;
  char IgnoreArg_pvParameter1;
  char IgnoreArg_ulParameter2;
  char IgnoreArg_xTicksToWait;

} CMOCK_xTimerPendFunctionCall_CALL_INSTANCE;

typedef struct _CMOCK_pcTimerGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  const char* ReturnVal;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_pcTimerGetName_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetReloadMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimerHandle_t Expected_xTimer;
  UBaseType_t Expected_uxAutoReload;
  char IgnoreArg_xTimer;
  char IgnoreArg_uxAutoReload;

} CMOCK_vTimerSetReloadMode_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetPeriod_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t ReturnVal;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_xTimerGetPeriod_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetExpiryTime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TickType_t ReturnVal;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_xTimerGetExpiryTime_CALL_INSTANCE;

typedef struct _CMOCK_xTimerCreateTimerTask_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;

} CMOCK_xTimerCreateTimerTask_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGenericCommand_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TimerHandle_t Expected_xTimer;
  BaseType_t Expected_xCommandID;
  TickType_t Expected_xOptionalValue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  TickType_t Expected_xTicksToWait;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char IgnoreArg_xTimer;
  char IgnoreArg_xCommandID;
  char IgnoreArg_xOptionalValue;
  char IgnoreArg_pxHigherPriorityTaskWoken;
  char IgnoreArg_xTicksToWait;

} CMOCK_xTimerGenericCommand_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetTimerNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TimerHandle_t Expected_xTimer;
  UBaseType_t Expected_uxTimerNumber;
  char IgnoreArg_xTimer;
  char IgnoreArg_uxTimerNumber;

} CMOCK_vTimerSetTimerNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE;

static struct MocktimersInstance
{
  char xTimerCreate_IgnoreBool;
  TimerHandle_t xTimerCreate_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerCreate_CallInstance;
  char xTimerCreateStatic_IgnoreBool;
  TimerHandle_t xTimerCreateStatic_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerCreateStatic_CallInstance;
  char pvTimerGetTimerID_IgnoreBool;
  void* pvTimerGetTimerID_FinalReturn;
  CMOCK_MEM_INDEX_TYPE pvTimerGetTimerID_CallInstance;
  char vTimerSetTimerID_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE vTimerSetTimerID_CallInstance;
  char xTimerIsTimerActive_IgnoreBool;
  BaseType_t xTimerIsTimerActive_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerIsTimerActive_CallInstance;
  char xTimerGetTimerDaemonTaskHandle_IgnoreBool;
  TaskHandle_t xTimerGetTimerDaemonTaskHandle_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerGetTimerDaemonTaskHandle_CallInstance;
  char xTimerPendFunctionCallFromISR_IgnoreBool;
  BaseType_t xTimerPendFunctionCallFromISR_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerPendFunctionCallFromISR_CallInstance;
  char xTimerPendFunctionCall_IgnoreBool;
  BaseType_t xTimerPendFunctionCall_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerPendFunctionCall_CallInstance;
  char pcTimerGetName_IgnoreBool;
  const char* pcTimerGetName_FinalReturn;
  CMOCK_MEM_INDEX_TYPE pcTimerGetName_CallInstance;
  char vTimerSetReloadMode_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE vTimerSetReloadMode_CallInstance;
  char xTimerGetPeriod_IgnoreBool;
  TickType_t xTimerGetPeriod_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerGetPeriod_CallInstance;
  char xTimerGetExpiryTime_IgnoreBool;
  TickType_t xTimerGetExpiryTime_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerGetExpiryTime_CallInstance;
  char xTimerCreateTimerTask_IgnoreBool;
  BaseType_t xTimerCreateTimerTask_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerCreateTimerTask_CallInstance;
  char xTimerGenericCommand_IgnoreBool;
  BaseType_t xTimerGenericCommand_FinalReturn;
  CMOCK_MEM_INDEX_TYPE xTimerGenericCommand_CallInstance;
  char vTimerSetTimerNumber_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE vTimerSetTimerNumber_CallInstance;
  char uxTimerGetTimerNumber_IgnoreBool;
  UBaseType_t uxTimerGetTimerNumber_FinalReturn;
  CMOCK_MEM_INDEX_TYPE uxTimerGetTimerNumber_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocktimers_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xTimerCreate_CallInstance;
  if (Mock.xTimerCreate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerCreateStatic_CallInstance;
  if (Mock.xTimerCreateStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pvTimerGetTimerID_CallInstance;
  if (Mock.pvTimerGetTimerID_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTimerGetTimerID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTimerSetTimerID_CallInstance;
  if (Mock.vTimerSetTimerID_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetTimerID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerIsTimerActive_CallInstance;
  if (Mock.xTimerIsTimerActive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerIsTimerActive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGetTimerDaemonTaskHandle_CallInstance;
  if (Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetTimerDaemonTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerPendFunctionCallFromISR_CallInstance;
  if (Mock.xTimerPendFunctionCallFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCallFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerPendFunctionCall_CallInstance;
  if (Mock.xTimerPendFunctionCall_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCall);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pcTimerGetName_CallInstance;
  if (Mock.pcTimerGetName_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcTimerGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTimerSetReloadMode_CallInstance;
  if (Mock.vTimerSetReloadMode_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetReloadMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGetPeriod_CallInstance;
  if (Mock.xTimerGetPeriod_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetPeriod);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGetExpiryTime_CallInstance;
  if (Mock.xTimerGetExpiryTime_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetExpiryTime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerCreateTimerTask_CallInstance;
  if (Mock.xTimerCreateTimerTask_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreateTimerTask);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.xTimerGenericCommand_CallInstance;
  if (Mock.xTimerGenericCommand_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGenericCommand);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.vTimerSetTimerNumber_CallInstance;
  if (Mock.vTimerSetTimerNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetTimerNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.uxTimerGetTimerNumber_CallInstance;
  if (Mock.uxTimerGetTimerNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTimerGetTimerNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mocktimers_Init(void)
{
  Mocktimers_Destroy();
}

void Mocktimers_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

TimerHandle_t xTimerCreate(const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreate);
  cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreate_CallInstance);
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreate_CallInstance);
  if (Mock.xTimerCreate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerCreate_FinalReturn;
    memcpy((void*)(&Mock.xTimerCreate_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TimerHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pcTimerName)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pcTimerName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTimerName, pcTimerName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTimerPeriodInTicks)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_xTimerPeriodInTicks);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxAutoReload)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvTimerID)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pvTimerID);
    if (cmock_call_instance->Expected_pvTimerID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTimerID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTimerID, pvTimerID, cmock_call_instance->Expected_pvTimerID_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxCallbackFunction)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pxCallbackFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction), sizeof(TimerCallbackFunction_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerCreate(CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction)
{
  cmock_call_instance->Expected_pcTimerName = pcTimerName;
  cmock_call_instance->IgnoreArg_pcTimerName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks),
         sizeof(TickType_t[sizeof(xTimerPeriodInTicks) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxAutoReload = 0;
  cmock_call_instance->Expected_pvTimerID = pvTimerID;
  cmock_call_instance->Expected_pvTimerID_Depth = pvTimerID_Depth;
  cmock_call_instance->IgnoreArg_pvTimerID = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction),
         sizeof(TimerCallbackFunction_t[sizeof(pxCallbackFunction) == sizeof(TimerCallbackFunction_t) ? 1 : -1])); /* add TimerCallbackFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 0;
}

void xTimerCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerCreate_IgnoreBool = (char)1;
}

void xTimerCreate_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerCreate(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, 1, pxCallbackFunction);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TimerHandle_t[sizeof(cmock_to_return) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerCreate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerCreate(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pvTimerID_Depth, pxCallbackFunction);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerCreate_CMockIgnoreArg_pcTimerName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcTimerName = 1;
}

void xTimerCreate_CMockIgnoreArg_xTimerPeriodInTicks(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 1;
}

void xTimerCreate_CMockIgnoreArg_uxAutoReload(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxAutoReload = 1;
}

void xTimerCreate_CMockIgnoreArg_pvTimerID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvTimerID = 1;
}

void xTimerCreate_CMockIgnoreArg_pxCallbackFunction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 1;
}

TimerHandle_t xTimerCreateStatic(const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreateStatic);
  cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreateStatic_CallInstance);
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateStatic_CallInstance);
  if (Mock.xTimerCreateStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerCreateStatic_FinalReturn;
    memcpy((void*)(&Mock.xTimerCreateStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TimerHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pcTimerName)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pcTimerName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTimerName, pcTimerName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTimerPeriodInTicks)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_xTimerPeriodInTicks);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxAutoReload)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvTimerID)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pvTimerID);
    if (cmock_call_instance->Expected_pvTimerID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTimerID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTimerID, pvTimerID, cmock_call_instance->Expected_pvTimerID_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxCallbackFunction)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pxCallbackFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction), sizeof(TimerCallbackFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxTimerBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pxTimerBuffer);
    if (cmock_call_instance->Expected_pxTimerBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTimerBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTimerBuffer), (void*)(pxTimerBuffer), sizeof(StaticTimer_t), cmock_call_instance->Expected_pxTimerBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerCreateStatic(CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, int pxTimerBuffer_Depth)
{
  cmock_call_instance->Expected_pcTimerName = pcTimerName;
  cmock_call_instance->IgnoreArg_pcTimerName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks),
         sizeof(TickType_t[sizeof(xTimerPeriodInTicks) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxAutoReload = 0;
  cmock_call_instance->Expected_pvTimerID = pvTimerID;
  cmock_call_instance->Expected_pvTimerID_Depth = pvTimerID_Depth;
  cmock_call_instance->IgnoreArg_pvTimerID = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction),
         sizeof(TimerCallbackFunction_t[sizeof(pxCallbackFunction) == sizeof(TimerCallbackFunction_t) ? 1 : -1])); /* add TimerCallbackFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 0;
  cmock_call_instance->Expected_pxTimerBuffer = pxTimerBuffer;
  cmock_call_instance->Expected_pxTimerBuffer_Depth = pxTimerBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxTimerBuffer = 0;
}

void xTimerCreateStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerCreateStatic_IgnoreBool = (char)1;
}

void xTimerCreateStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerCreateStatic(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, 1, pxCallbackFunction, pxTimerBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TimerHandle_t[sizeof(cmock_to_return) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerCreateStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, int pxTimerBuffer_Depth, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerCreateStatic(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pvTimerID_Depth, pxCallbackFunction, pxTimerBuffer, pxTimerBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerCreateStatic_CMockIgnoreArg_pcTimerName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcTimerName = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_xTimerPeriodInTicks(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_uxAutoReload(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxAutoReload = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_pvTimerID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvTimerID = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_pxCallbackFunction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_pxTimerBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTimerBuffer = 1;
}

void* pvTimerGetTimerID(const TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTimerGetTimerID);
  cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTimerGetTimerID_CallInstance);
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemNext(Mock.pvTimerGetTimerID_CallInstance);
  if (Mock.pvTimerGetTimerID_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pvTimerGetTimerID_FinalReturn;
    Mock.pvTimerGetTimerID_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_pvTimerGetTimerID,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pvTimerGetTimerID(CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance, const TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void pvTimerGetTimerID_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTimerGetTimerID_CALL_INSTANCE));
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemChain(Mock.pvTimerGetTimerID_CallInstance, cmock_guts_index);
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pvTimerGetTimerID_IgnoreBool = (char)1;
}

void pvTimerGetTimerID_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTimerGetTimerID_CALL_INSTANCE));
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemChain(Mock.pvTimerGetTimerID_CallInstance, cmock_guts_index);
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void pvTimerGetTimerID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TimerHandle_t xTimer, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTimerGetTimerID_CALL_INSTANCE));
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemChain(Mock.pvTimerGetTimerID_CallInstance, cmock_guts_index);
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_pvTimerGetTimerID(cmock_call_instance, xTimer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pvTimerGetTimerID_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pvTimerGetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetTimerID(TimerHandle_t xTimer, void* pvNewID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetTimerID);
  cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetTimerID_CallInstance);
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetTimerID_CallInstance);
  if (Mock.vTimerSetTimerID_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerID,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvNewID)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerID,CMockString_pvNewID);
    if (cmock_call_instance->Expected_pvNewID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvNewID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvNewID, pvNewID, cmock_call_instance->Expected_pvNewID_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetTimerID(CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, void* pvNewID, int pvNewID_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  cmock_call_instance->Expected_pvNewID = pvNewID;
  cmock_call_instance->Expected_pvNewID_Depth = pvNewID_Depth;
  cmock_call_instance->IgnoreArg_pvNewID = 0;
}

void vTimerSetTimerID_CMockIgnore(void)
{
  Mock.vTimerSetTimerID_IgnoreBool = (char)1;
}

void vTimerSetTimerID_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerID_CALL_INSTANCE));
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerID_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTimerSetTimerID_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, void* pvNewID)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerID_CALL_INSTANCE));
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerID_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTimerSetTimerID(cmock_call_instance, xTimer, pvNewID, 1);
}

void vTimerSetTimerID_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, void* pvNewID, int pvNewID_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerID_CALL_INSTANCE));
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerID_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTimerSetTimerID(cmock_call_instance, xTimer, pvNewID, pvNewID_Depth);
}

void vTimerSetTimerID_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetTimerID_CMockIgnoreArg_pvNewID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvNewID = 1;
}

BaseType_t xTimerIsTimerActive(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerIsTimerActive);
  cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerIsTimerActive_CallInstance);
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemNext(Mock.xTimerIsTimerActive_CallInstance);
  if (Mock.xTimerIsTimerActive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerIsTimerActive_FinalReturn;
    memcpy((void*)(&Mock.xTimerIsTimerActive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerIsTimerActive,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerIsTimerActive(CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void xTimerIsTimerActive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerIsTimerActive_CALL_INSTANCE));
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemChain(Mock.xTimerIsTimerActive_CallInstance, cmock_guts_index);
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerIsTimerActive_IgnoreBool = (char)1;
}

void xTimerIsTimerActive_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerIsTimerActive_CALL_INSTANCE));
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemChain(Mock.xTimerIsTimerActive_CallInstance, cmock_guts_index);
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerIsTimerActive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerIsTimerActive_CALL_INSTANCE));
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemChain(Mock.xTimerIsTimerActive_CallInstance, cmock_guts_index);
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerIsTimerActive(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerIsTimerActive_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerIsTimerActive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

TaskHandle_t xTimerGetTimerDaemonTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetTimerDaemonTaskHandle);
  cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  if (Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGetTimerDaemonTaskHandle_FinalReturn;
    memcpy((void*)(&Mock.xTimerGetTimerDaemonTaskHandle_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TaskHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTimerGetTimerDaemonTaskHandle_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE));
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance, cmock_guts_index);
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)1;
}

void xTimerGetTimerDaemonTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE));
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance, cmock_guts_index);
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCallFromISR);
  cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  if (Mock.xTimerPendFunctionCallFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerPendFunctionCallFromISR_FinalReturn;
    memcpy((void*)(&Mock.xTimerPendFunctionCallFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xFunctionToPend)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_xFunctionToPend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend), sizeof(PendedFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameter1)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_pvParameter1);
    if (cmock_call_instance->Expected_pvParameter1 == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter1, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter1, pvParameter1, cmock_call_instance->Expected_pvParameter1_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulParameter2)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_ulParameter2);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulParameter2, ulParameter2, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerPendFunctionCallFromISR(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend),
         sizeof(PendedFunction_t[sizeof(xFunctionToPend) == sizeof(PendedFunction_t) ? 1 : -1])); /* add PendedFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xFunctionToPend = 0;
  cmock_call_instance->Expected_pvParameter1 = pvParameter1;
  cmock_call_instance->Expected_pvParameter1_Depth = pvParameter1_Depth;
  cmock_call_instance->IgnoreArg_pvParameter1 = 0;
  cmock_call_instance->Expected_ulParameter2 = ulParameter2;
  cmock_call_instance->IgnoreArg_ulParameter2 = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)1;
}

void xTimerPendFunctionCallFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerPendFunctionCallFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerPendFunctionCallFromISR(cmock_call_instance, xFunctionToPend, pvParameter1, 1, ulParameter2, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerPendFunctionCallFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerPendFunctionCallFromISR(cmock_call_instance, xFunctionToPend, pvParameter1, pvParameter1_Depth, ulParameter2, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_xFunctionToPend(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xFunctionToPend = 1;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_pvParameter1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameter1 = 1;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_ulParameter2(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulParameter2 = 1;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

BaseType_t xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCall);
  cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerPendFunctionCall_CallInstance);
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCall_CallInstance);
  if (Mock.xTimerPendFunctionCall_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerPendFunctionCall_FinalReturn;
    memcpy((void*)(&Mock.xTimerPendFunctionCall_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xFunctionToPend)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_xFunctionToPend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend), sizeof(PendedFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameter1)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_pvParameter1);
    if (cmock_call_instance->Expected_pvParameter1 == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter1, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter1, pvParameter1, cmock_call_instance->Expected_pvParameter1_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulParameter2)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_ulParameter2);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulParameter2, ulParameter2, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerPendFunctionCall(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend),
         sizeof(PendedFunction_t[sizeof(xFunctionToPend) == sizeof(PendedFunction_t) ? 1 : -1])); /* add PendedFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xFunctionToPend = 0;
  cmock_call_instance->Expected_pvParameter1 = pvParameter1;
  cmock_call_instance->Expected_pvParameter1_Depth = pvParameter1_Depth;
  cmock_call_instance->IgnoreArg_pvParameter1 = 0;
  cmock_call_instance->Expected_ulParameter2 = ulParameter2;
  cmock_call_instance->IgnoreArg_ulParameter2 = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xTimerPendFunctionCall_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)1;
}

void xTimerPendFunctionCall_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerPendFunctionCall_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerPendFunctionCall(cmock_call_instance, xFunctionToPend, pvParameter1, 1, ulParameter2, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerPendFunctionCall_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerPendFunctionCall(cmock_call_instance, xFunctionToPend, pvParameter1, pvParameter1_Depth, ulParameter2, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerPendFunctionCall_CMockIgnoreArg_xFunctionToPend(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xFunctionToPend = 1;
}

void xTimerPendFunctionCall_CMockIgnoreArg_pvParameter1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameter1 = 1;
}

void xTimerPendFunctionCall_CMockIgnoreArg_ulParameter2(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulParameter2 = 1;
}

void xTimerPendFunctionCall_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

const char* pcTimerGetName(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcTimerGetName);
  cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcTimerGetName_CallInstance);
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemNext(Mock.pcTimerGetName_CallInstance);
  if (Mock.pcTimerGetName_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pcTimerGetName_FinalReturn;
    Mock.pcTimerGetName_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_pcTimerGetName,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcTimerGetName(CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void pcTimerGetName_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTimerGetName_CALL_INSTANCE));
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTimerGetName_CallInstance, cmock_guts_index);
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pcTimerGetName_IgnoreBool = (char)1;
}

void pcTimerGetName_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTimerGetName_CALL_INSTANCE));
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTimerGetName_CallInstance, cmock_guts_index);
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void pcTimerGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTimerGetName_CALL_INSTANCE));
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTimerGetName_CallInstance, cmock_guts_index);
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_pcTimerGetName(cmock_call_instance, xTimer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pcTimerGetName_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pcTimerGetName_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetReloadMode(TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetReloadMode);
  cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetReloadMode_CallInstance);
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetReloadMode_CallInstance);
  if (Mock.vTimerSetReloadMode_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetReloadMode,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxAutoReload)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetReloadMode,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetReloadMode(CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxAutoReload = 0;
}

void vTimerSetReloadMode_CMockIgnore(void)
{
  Mock.vTimerSetReloadMode_IgnoreBool = (char)1;
}

void vTimerSetReloadMode_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetReloadMode_CALL_INSTANCE));
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetReloadMode_CallInstance, cmock_guts_index);
  Mock.vTimerSetReloadMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTimerSetReloadMode_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetReloadMode_CALL_INSTANCE));
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetReloadMode_CallInstance, cmock_guts_index);
  Mock.vTimerSetReloadMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTimerSetReloadMode(cmock_call_instance, xTimer, uxAutoReload);
}

void vTimerSetReloadMode_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetReloadMode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetReloadMode_CMockIgnoreArg_uxAutoReload(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetReloadMode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxAutoReload = 1;
}

TickType_t xTimerGetPeriod(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetPeriod);
  cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetPeriod_CallInstance);
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetPeriod_CallInstance);
  if (Mock.xTimerGetPeriod_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGetPeriod_FinalReturn;
    memcpy((void*)(&Mock.xTimerGetPeriod_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TickType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGetPeriod,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGetPeriod(CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void xTimerGetPeriod_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetPeriod_CALL_INSTANCE));
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetPeriod_CallInstance, cmock_guts_index);
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGetPeriod_IgnoreBool = (char)1;
}

void xTimerGetPeriod_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetPeriod_CALL_INSTANCE));
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetPeriod_CallInstance, cmock_guts_index);
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerGetPeriod_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetPeriod_CALL_INSTANCE));
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetPeriod_CallInstance, cmock_guts_index);
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerGetPeriod(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTimerGetPeriod_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGetPeriod_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

TickType_t xTimerGetExpiryTime(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetExpiryTime);
  cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetExpiryTime_CallInstance);
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetExpiryTime_CallInstance);
  if (Mock.xTimerGetExpiryTime_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGetExpiryTime_FinalReturn;
    memcpy((void*)(&Mock.xTimerGetExpiryTime_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TickType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGetExpiryTime,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGetExpiryTime(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void xTimerGetExpiryTime_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE));
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetExpiryTime_CallInstance, cmock_guts_index);
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)1;
}

void xTimerGetExpiryTime_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE));
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetExpiryTime_CallInstance, cmock_guts_index);
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerGetExpiryTime_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE));
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetExpiryTime_CallInstance, cmock_guts_index);
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerGetExpiryTime(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTimerGetExpiryTime_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGetExpiryTime_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

BaseType_t xTimerCreateTimerTask(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreateTimerTask);
  cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreateTimerTask_CallInstance);
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateTimerTask_CallInstance);
  if (Mock.xTimerCreateTimerTask_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerCreateTimerTask_FinalReturn;
    memcpy((void*)(&Mock.xTimerCreateTimerTask_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTimerCreateTimerTask_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateTimerTask_CALL_INSTANCE));
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateTimerTask_CallInstance, cmock_guts_index);
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)1;
}

void xTimerCreateTimerTask_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateTimerTask_CALL_INSTANCE));
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateTimerTask_CallInstance, cmock_guts_index);
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

BaseType_t xTimerGenericCommand(TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGenericCommand);
  cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGenericCommand_CallInstance);
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemNext(Mock.xTimerGenericCommand_CallInstance);
  if (Mock.xTimerGenericCommand_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGenericCommand_FinalReturn;
    memcpy((void*)(&Mock.xTimerGenericCommand_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xCommandID)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xCommandID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCommandID), (void*)(&xCommandID), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xOptionalValue)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xOptionalValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xOptionalValue), (void*)(&xOptionalValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGenericCommand(CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xCommandID), (void*)(&xCommandID),
         sizeof(BaseType_t[sizeof(xCommandID) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCommandID = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xOptionalValue), (void*)(&xOptionalValue),
         sizeof(TickType_t[sizeof(xOptionalValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xOptionalValue = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xTimerGenericCommand_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGenericCommand_IgnoreBool = (char)1;
}

void xTimerGenericCommand_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xTimerGenericCommand_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerGenericCommand(cmock_call_instance, xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerGenericCommand_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xTimerGenericCommand(cmock_call_instance, xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerGenericCommand_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_xCommandID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCommandID = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_xOptionalValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xOptionalValue = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vTimerSetTimerNumber(TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetTimerNumber);
  cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetTimerNumber_CallInstance);
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetTimerNumber_CallInstance);
  if (Mock.vTimerSetTimerNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerNumber,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxTimerNumber)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerNumber,CMockString_uxTimerNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxTimerNumber), (void*)(&uxTimerNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetTimerNumber(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxTimerNumber), (void*)(&uxTimerNumber),
         sizeof(UBaseType_t[sizeof(uxTimerNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxTimerNumber = 0;
}

void vTimerSetTimerNumber_CMockIgnore(void)
{
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)1;
}

void vTimerSetTimerNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE));
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerNumber_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vTimerSetTimerNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE));
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerNumber_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vTimerSetTimerNumber(cmock_call_instance, xTimer, uxTimerNumber);
}

void vTimerSetTimerNumber_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetTimerNumber_CMockIgnoreArg_uxTimerNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxTimerNumber = 1;
}

UBaseType_t uxTimerGetTimerNumber(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTimerGetTimerNumber);
  cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTimerGetTimerNumber_CallInstance);
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.uxTimerGetTimerNumber_CallInstance);
  if (Mock.uxTimerGetTimerNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxTimerGetTimerNumber_FinalReturn;
    memcpy((void*)(&Mock.uxTimerGetTimerNumber_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_uxTimerGetTimerNumber,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTimerGetTimerNumber(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void uxTimerGetTimerNumber_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE));
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetTimerNumber_CallInstance, cmock_guts_index);
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)1;
}

void uxTimerGetTimerNumber_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE));
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetTimerNumber_CallInstance, cmock_guts_index);
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxTimerGetTimerNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE));
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetTimerNumber_CallInstance, cmock_guts_index);
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxTimerGetTimerNumber(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTimerGetTimerNumber_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTimerGetTimerNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

